{"version":3,"file":"static/js/212.ee2a4db7.chunk.js","mappings":"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","sources":["../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.min.js","../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.min.js","../node_modules/use-sync-external-store/shim/index.js","../node_modules/use-sync-external-store/shim/with-selector.js","../node_modules/effector-react/effector-react/apiBase.ts","../node_modules/effector-react/effector-react/scope.ts","../node_modules/effector-react/effector-react/nossr.ts","../node_modules/effector-react/effector-react/throw.ts","../node_modules/effector-react/effector-react/useDeprecate.ts","../node_modules/effector-react/effector-react/useIsomorphicLayoutEffect.ts","../node_modules/effector/effector/collection.ts","../node_modules/effector/effector/throw.ts","../node_modules/effector/effector/createNode.ts","../node_modules/effector/effector/tag.ts","../node_modules/effector/effector/kernel.ts","../node_modules/effector/effector/naming.ts","../node_modules/effector/effector/config.ts","../node_modules/effector/effector/subscription.ts","../node_modules/effector/effector/template.ts","../node_modules/effector/effector/createUnit.ts","../node_modules/effector/effector/combine.ts","../node_modules/effector/effector/defer.ts","../node_modules/effector/effector/createEffect.ts","../node_modules/effector/effector/merge.ts","../node_modules/effector/effector/sample.ts","../node_modules/effector/effector/fork/scopeBind.ts","../node_modules/effector/effector/createWatch.ts","../node_modules/effector/effector/observable.ts","../node_modules/effector/effector/getter.ts","../node_modules/effector/effector/validate.ts","../node_modules/effector/effector/id.ts","../node_modules/effector/effector/region.ts","../node_modules/effector/effector/own.ts","../node_modules/effector/effector/is.ts","../node_modules/effector/effector/caller.ts","../node_modules/effector/effector/step.ts","../node_modules/effector/effector/stateRef.ts","../node_modules/effector/effector/clearNode.ts","../node_modules/effector/effector/forward.ts","../node_modules/effector/effector/watch.ts"],"sourcesContent":["/**\n * @license React\n * use-sync-external-store-shim.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var e=require(\"react\");function h(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var k=\"function\"===typeof Object.is?Object.is:h,l=e.useState,m=e.useEffect,n=e.useLayoutEffect,p=e.useDebugValue;function q(a,b){var d=b(),f=l({inst:{value:d,getSnapshot:b}}),c=f[0].inst,g=f[1];n(function(){c.value=d;c.getSnapshot=b;r(c)&&g({inst:c})},[a,d,b]);m(function(){r(c)&&g({inst:c});return a(function(){r(c)&&g({inst:c})})},[a]);p(d);return d}\nfunction r(a){var b=a.getSnapshot;a=a.value;try{var d=b();return!k(a,d)}catch(f){return!0}}function t(a,b){return b()}var u=\"undefined\"===typeof window||\"undefined\"===typeof window.document||\"undefined\"===typeof window.document.createElement?t:q;exports.useSyncExternalStore=void 0!==e.useSyncExternalStore?e.useSyncExternalStore:u;\n","/**\n * @license React\n * use-sync-external-store-shim/with-selector.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var h=require(\"react\"),n=require(\"use-sync-external-store/shim\");function p(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var q=\"function\"===typeof Object.is?Object.is:p,r=n.useSyncExternalStore,t=h.useRef,u=h.useEffect,v=h.useMemo,w=h.useDebugValue;\nexports.useSyncExternalStoreWithSelector=function(a,b,e,l,g){var c=t(null);if(null===c.current){var f={hasValue:!1,value:null};c.current=f}else f=c.current;c=v(function(){function a(a){if(!c){c=!0;d=a;a=l(a);if(void 0!==g&&f.hasValue){var b=f.value;if(g(b,a))return k=b}return k=a}b=k;if(q(d,a))return b;var e=l(a);if(void 0!==g&&g(b,e))return b;d=a;return k=e}var c=!1,d,k,m=void 0===e?null:e;return[function(){return a(b())},null===m?void 0:function(){return a(m())}]},[b,e,l,g]);var d=r(a,c[0],c[1]);\nu(function(){f.hasValue=!0;f.value=d},[d]);w(d);return d};\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim.production.min.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim.development.js');\n}\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.production.min.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.development.js');\n}\n","import {Store, is, scopeBind, Scope, Unit, Event, createWatch} from 'effector'\nimport React from 'react'\nimport {useSyncExternalStore} from 'use-sync-external-store/shim'\nimport {useSyncExternalStoreWithSelector} from 'use-sync-external-store/shim/with-selector'\nimport {throwError} from './throw'\nimport {withDisplayName} from './withDisplayName'\nimport {useIsomorphicLayoutEffect} from './useIsomorphicLayoutEffect'\nimport {Gate} from './index.h'\nimport {useDeprecate} from './useDeprecate'\n\nconst stateReader = <T>(store: Store<T>, scope?: Scope) =>\n  scope ? scope.getState(store) : store.getState()\nconst basicUpdateFilter = <T>(upd: T, oldValue: T) => upd !== oldValue\nconst keysEqual = (a?: readonly any[], b?: readonly any[]) => {\n  if (!a || !b || a.length !== b.length) return false\n\n  let isEqual = true\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      isEqual = false\n      break\n    }\n  }\n\n  return isEqual\n}\n\nexport function useStoreBase<State>(store: Store<State>, scope?: Scope) {\n  useDeprecate(true, 'useStore', 'useUnit')\n  if (!is.store(store)) throwError('expect useStore argument to be a store')\n\n  const subscribe = React.useCallback(\n    (fn: () => void) => createWatch({unit: store, fn, scope}),\n    [store, scope],\n  )\n  const read = React.useCallback(\n    () => stateReader(store, scope),\n    [store, scope],\n  )\n  const currentValue = useSyncExternalStore(subscribe, read, read)\n\n  return currentValue\n}\n\nexport function useUnitBase<Shape extends {[key: string]: Unit<any>}>(\n  shape: Shape | {'@@unitShape': () => Shape},\n  scope?: Scope,\n) {\n  const isSingleUnit = is.unit(shape)\n  let normShape: {[key: string]: Unit<any>} = {}\n  if (isSingleUnit) {\n    normShape = {unit: shape}\n  } else if ('@@unitShape' in shape) {\n    if (typeof shape['@@unitShape'] === 'function') {\n      normShape = shape['@@unitShape']()\n    } else {\n      throwError('expect @@unitShape to be a function')\n    }\n  } else {\n    normShape = shape\n  }\n  const isList = Array.isArray(normShape)\n  const flagsRef = React.useRef({\n    stale: true,\n    justSubscribed: false,\n    scope,\n  })\n  const [eventsShape, storeKeys, storeValues, eventKeys, eventValues] =\n    React.useMemo(() => {\n      flagsRef.current.stale = true\n      const shape = Array.isArray(normShape) ? [] : ({} as any)\n      const storeKeys: string[] = []\n      const storeValues: Array<Store<any>> = []\n      const eventKeys: string[] = []\n      const eventValues: Array<Unit<any>> = []\n      for (const key in normShape) {\n        if (!Object.prototype.hasOwnProperty.call(normShape, key)) continue\n        const unit = normShape[key]\n        if (!is.unit(unit)) {\n          const keyMessage = isSingleUnit ? 'argument' : `value in key \"${key}\"`\n          throwError(`expect useUnit ${keyMessage} to be a unit`)\n        }\n        if (is.event(unit) || is.effect(unit)) {\n          shape[key] = scope ? scopeBind(unit as Event<any>, {scope}) : unit\n          eventKeys.push(key)\n          eventValues.push(unit)\n        } else {\n          shape[key] = null\n          storeKeys.push(key)\n          storeValues.push(unit as Store<any>)\n        }\n      }\n      return [shape, storeKeys, storeValues, eventKeys, eventValues]\n    }, [\n      flagsRef,\n      scope,\n      ...Object.keys(normShape),\n      ...Object.values(normShape),\n    ])\n  const stateRef = React.useRef({\n    value: eventsShape,\n    storeKeys,\n    eventKeys,\n    eventValues,\n  })\n  const subscribe = React.useCallback(\n    (cb: () => void) => {\n      const flags = flagsRef.current\n      flags.justSubscribed = true\n      const cbCaller = () => {\n        if (!flags.stale) {\n          flags.stale = true\n          cb()\n        }\n      }\n      return createWatch({unit: storeValues, fn: cbCaller, scope, batch: true})\n    },\n    [storeValues, scope, stateRef, flagsRef],\n  )\n  const read = React.useCallback(() => {\n    const state = stateRef.current\n    const flags = flagsRef.current\n    let resultValue\n    let changed = false\n    const oldVal = state.value\n    const oldStoreKeys = state.storeKeys\n    const oldEventKeys = state.eventKeys\n    const oldEventValues = state.eventValues\n    const scopeChanged = scope !== flags.scope\n    if (flags.stale || flags.justSubscribed || scopeChanged) {\n      changed = !flags.justSubscribed || scopeChanged\n      resultValue = isList ? [...eventsShape] : {...eventsShape}\n      if (\n        oldStoreKeys.length !== storeKeys.length ||\n        oldEventKeys.length !== eventKeys.length\n      ) {\n        changed = true\n      }\n      for (let i = 0; i < storeKeys.length; i++) {\n        const updatedValue = stateReader(storeValues[i], scope)\n        const key = storeKeys[i]\n        if (!changed) {\n          if (!oldStoreKeys.includes(key)) {\n            changed = true\n          } else {\n            changed = oldVal[key] !== updatedValue\n          }\n        }\n        resultValue[key] = updatedValue\n      }\n      for (let i = 0; i < eventKeys.length; i++) {\n        const updatedValue = eventValues[i]\n        const key = eventKeys[i]\n        if (!changed) {\n          if (!oldEventKeys.includes(key)) {\n            changed = true\n          } else {\n            changed = oldEventValues[oldEventKeys.indexOf(key)] !== updatedValue\n          }\n        }\n      }\n    }\n    if (changed) {\n      state.value = resultValue\n    }\n    state.storeKeys = storeKeys\n    state.eventKeys = eventKeys\n    state.eventValues = eventValues\n    flags.stale = false\n    flags.justSubscribed = !changed\n    flags.scope = scope\n    return isSingleUnit ? state.value.unit : state.value\n  }, [subscribe, storeValues, eventValues, scope, stateRef, flagsRef])\n  return useSyncExternalStore(subscribe, read, read)\n}\n\nexport function useStoreMapBase<State, Result, Keys extends ReadonlyArray<any>>(\n  [configOrStore, separateFn]: [\n    configOrStore:\n      | {\n          store: Store<State>\n          keys: Keys\n          fn(state: State, keys: Keys): Result\n          updateFilter?: (update: Result, current: Result) => boolean\n          defaultValue?: Result\n        }\n      | Store<State>,\n    separateFn?: (state: State, keys: Keys) => Result,\n  ],\n  scope?: Scope,\n): Result {\n  let fn: (state: State, keys: Keys) => Result\n  let updateFilter: (update: Result, current: Result) => boolean =\n    basicUpdateFilter\n  let defaultValue: Result | undefined\n  let store: Store<State>\n  let keys: Keys\n  if (separateFn) {\n    fn = separateFn\n    store = configOrStore as Store<State>\n    keys = [] as unknown as Keys\n  } else {\n    ;({\n      fn,\n      store,\n      keys,\n      defaultValue,\n      updateFilter = basicUpdateFilter,\n    } = configOrStore as any)\n  }\n  if (!is.store(store)) throwError('useStoreMap expects a store')\n  if (!Array.isArray(keys)) throwError('useStoreMap expects an array as keys')\n  if (typeof fn !== 'function') throwError('useStoreMap expects a function')\n\n  const subscribe = React.useCallback(\n    (fn: () => void) => createWatch({unit: store, fn, scope}),\n    [store, scope],\n  )\n  const read = React.useCallback(\n    () => stateReader(store, scope),\n    [store, scope],\n  )\n\n  const stateRef = React.useRef<State>()\n  const valueRef = React.useRef<Result>()\n  const keysRef = React.useRef(keys)\n\n  const value = useSyncExternalStoreWithSelector(\n    subscribe,\n    read,\n    read,\n    state => {\n      if (stateRef.current !== state || !keysEqual(keysRef.current, keys)) {\n        let result = fn(state, keys)\n        if (result === undefined && defaultValue !== undefined) {\n          result = defaultValue\n        }\n        stateRef.current = state\n        keysRef.current = keys\n\n        /**\n         * skip update, if undefined\n         * just like original store or previous implementation\n         */\n        if (result !== undefined) {\n          valueRef.current = result\n        }\n      }\n\n      return valueRef.current as Result\n    },\n    (current, update) => !updateFilter(update, current),\n  )\n\n  return value\n}\nexport function useListBase<T>(\n  list: Store<T[]>,\n  renderItem:\n    | {\n        keys?: any[]\n        fn(item: T, index: number): React.ReactNode\n        getKey?: (item: T) => string\n        placeholder?: React.ReactNode\n      }\n    | ((item: T, index: number) => React.ReactNode),\n  scope?: Scope,\n): React.ReactNode {\n  let keys = [] as any[]\n  let fn\n  let getKey: ((item: T) => string) | void\n  let placeholder: React.ReactNode | void\n  if (typeof renderItem === 'object' && renderItem !== null) {\n    if (renderItem.keys) keys = renderItem.keys\n    ;({fn, getKey, placeholder} = renderItem)\n  } else {\n    fn = renderItem\n  }\n  if (!is.store(list)) throwError('expect useList first argument to be a store')\n  if (typeof fn !== 'function')\n    throwError(\"expect useList's renderItem to be a function\")\n  if (!Array.isArray(keys)) throwError(\"expect useList's keys to be an array\")\n  const Item = React.useMemo(() => {\n    const Item = withDisplayName(\n      `${list.shortName || 'Unknown'}.Item`,\n      (\n        props:\n          | {index: number; keys: any[]; keyVal: never; value: never}\n          | {index: never; keys: any[]; keyVal: string; value: T},\n      ) => {\n        const {index, keys, keyVal, value} = props\n        const isKeyed = !!fnRef.current[1]\n        if (isKeyed) {\n          return fnRef.current[0](value, keyVal as any)\n        }\n        const item = useStoreMapBase(\n          [\n            {\n              store: list,\n              keys: [index, ...keys],\n              fn: (list, keys) => list[keys[0]],\n            },\n          ],\n          scope,\n        )\n        return fnRef.current[0](item, index)\n      },\n    )\n    return React.memo(Item)\n  }, [list, scope, !!getKey!])\n  const fnRef = React.useRef([fn, getKey!] as const)\n  fnRef.current = [fn, getKey!]\n  const keysSelfMemo = React.useMemo(() => keys, keys)\n  if (getKey!) {\n    const listItems = useUnitBase(list, scope)\n    if (listItems.length === 0 && placeholder) return placeholder\n    return listItems.map(value => {\n      const key = fnRef.current[1](value)\n      return React.createElement(Item, {\n        keyVal: key,\n        key,\n        keys: keysSelfMemo,\n        value,\n      })\n    })\n  } else {\n    const length = useStoreMapBase(\n      [\n        {\n          store: list,\n          keys: [list],\n          fn: list => list.length,\n        },\n      ],\n      scope,\n    )\n    if (length === 0 && placeholder) return placeholder\n    return Array.from({length}, (_, i) =>\n      React.createElement(Item, {\n        index: i,\n        key: i,\n        keys: keysSelfMemo,\n      }),\n    )\n  }\n}\n\nexport function useEventBase(eventObject: any, scope?: Scope) {\n  useDeprecate(true, 'useEvent', 'useUnit')\n  if (!scope) {\n    return eventObject\n  }\n  const isShape = !is.unit(eventObject) && typeof eventObject === 'object'\n  const events = isShape ? eventObject : {event: eventObject}\n\n  return React.useMemo(() => {\n    if (is.unit(eventObject)) {\n      //@ts-expect-error\n      return scopeBind(eventObject, {scope})\n    }\n    const shape = Array.isArray(eventObject) ? [] : ({} as any)\n    for (const key in eventObject) {\n      shape[key] = scopeBind(eventObject[key], {scope})\n    }\n    return shape\n  }, [scope, ...Object.keys(events), ...Object.values(events)])\n}\n\nexport function useGateBase<Props>(\n  GateComponent: Gate<Props>,\n  props: Props = {} as any,\n  scope?: Scope,\n) {\n  const {open, close, set} = useUnitBase(\n    {\n      open: GateComponent.open,\n      close: GateComponent.close,\n      set: GateComponent.set,\n    },\n    scope,\n  )\n  const ForkedGate = React.useMemo(\n    () =>\n      ({\n        open,\n        close,\n        set,\n      } as Gate<Props>),\n    [GateComponent, open],\n  )\n\n  const propsRef = React.useRef<{value: any; count: number}>({\n    value: null,\n    count: 0,\n  })\n  useIsomorphicLayoutEffect(() => {\n    ForkedGate.open(propsRef.current.value)\n    return () => ForkedGate.close(propsRef.current.value) as any\n  }, [ForkedGate])\n  if (!shallowCompare(propsRef.current.value, props)) {\n    propsRef.current.value = props\n    propsRef.current.count += 1\n  }\n  useIsomorphicLayoutEffect(() => {\n    ForkedGate.set(propsRef.current.value)\n  }, [propsRef.current.count])\n}\n\nfunction shallowCompare(a: any, b: any) {\n  if (a === b) return true\n  if (\n    typeof a === 'object' &&\n    a !== null &&\n    typeof b === 'object' &&\n    b !== null\n  ) {\n    const aKeys = Object.keys(a)\n    const bKeys = Object.keys(b)\n    if (aKeys.length !== bKeys.length) return false\n    for (let i = 0; i < aKeys.length; i++) {\n      const key = aKeys[i]\n      if (a[key] !== b[key]) return false\n    }\n    return true\n  }\n  return false\n}\n","import React from 'react'\nimport {Scope} from 'effector'\nimport {throwError} from './throw'\n\nconst ScopeContext = React.createContext(null as Scope | null)\nexport const {Provider} = ScopeContext\nexport function getScope(forceScope?: boolean) {\n  const scope = React.useContext(ScopeContext)\n  if (forceScope && !scope)\n    throwError('No scope found, consider adding <Provider> to app root')\n  return scope as Scope\n}\n","import {Event, Store, Scope} from 'effector'\nimport {\n  useStoreBase,\n  useStoreMapBase,\n  useListBase,\n  useUnitBase,\n  useEventBase,\n  useGateBase,\n} from './apiBase'\nimport {getScope} from './scope'\nimport type {Gate} from './index.h'\n\n/**\nbind event to scope\n\nworks like React.useCallback, but for scopes\n*/\nexport function useEvent<T>(\n  event: Event<T>,\n  opts?: {forceScope?: boolean},\n): (payload: T) => T {\n  const scope = getScope(opts?.forceScope)\n\n  return useEventBase(event, scope)\n}\n\nexport function useStore<State>(\n  store: Store<State>,\n  opts?: {forceScope?: boolean},\n): State {\n  return useStoreBase(store, getScope(opts?.forceScope))\n}\n\nexport function useUnit(shape, opts?: {forceScope?: boolean}) {\n  return useUnitBase(shape, getScope(opts?.forceScope))\n}\n\nexport function useStoreMap<State, Result, Keys extends ReadonlyArray<any>>(\n  configOrStore:\n    | {\n        store: Store<State>\n        keys: Keys\n        fn(state: State, keys: Keys): Result\n        updateFilter?: (update: Result, current: Result) => boolean\n        defaultValue?: Result\n        forceScope?: boolean\n      }\n    | Store<State>,\n  separateFn?: (state: State, keys: Keys) => Result,\n): Result {\n  return useStoreMapBase(\n    [configOrStore, separateFn],\n    getScope(configOrStore?.forceScope),\n  )\n}\n\nexport function useList<T>(\n  list: Store<T[]>,\n  renderItem:\n    | {\n        keys?: any[]\n        fn(item: T, index: number): React.ReactNode\n        getKey?: (item: T) => string\n        placeholder?: React.ReactNode\n      }\n    | ((item: T, index: number) => React.ReactNode),\n  opts?: {forceScope?: boolean},\n): React.ReactNode {\n  return useListBase(list, renderItem, getScope(opts?.forceScope))\n}\n\nexport function useGate<Props>(\n  GateComponent: Gate<Props>,\n  props: Props = {} as any,\n  opts?: {forceScope?: boolean},\n) {\n  return useGateBase(GateComponent, props, getScope(opts?.forceScope))\n}\n\nexport function useProvidedScope(): Scope | null {\n  const scope = getScope() || null\n  return scope\n}\n","export const throwError = (message: string) => {\n  throw Error(message)\n}\n","import {useEffect} from 'react'\n\nexport const useDeprecate = (\n  cond: boolean,\n  subject: string,\n  useInstead?: string,\n) => {\n  useEffect(() => {\n    if (cond) {\n      console.error(\n        `${subject} is deprecated${\n          useInstead ? `, prefer ${useInstead} instead` : ''\n        }`,\n      )\n    }\n  }, [cond, subject, useInstead])\n}\n","import React from 'react'\n\nexport const useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect\n","export function forIn<T, Key extends string = string>(\n  obj: Record<Key, T>,\n  cb: (value: T, key: Key) => void,\n) {\n  for (const key in obj) {\n    cb(obj[key], key)\n  }\n}\n\nexport const includes = <T>(list: T[], item: T) => list.includes(item)\n\nexport const removeItem = <T>(list: T[], item: T) => {\n  const pos = list.indexOf(item)\n  if (pos !== -1) {\n    list.splice(pos, 1)\n  }\n}\n\nexport const add = <T>(list: T[], item: T) => list.push(item)\n\nexport function forEach<T>(\n  list: T[],\n  fn: (item: T, index: number, list: T[]) => void,\n): void\nexport function forEach<K, T>(\n  list: Map<K, T>,\n  fn: (item: T, key: K) => void,\n): void\nexport function forEach<T>(list: Set<T>, fn: (item: T) => void): void\nexport function forEach(list: any, fn: Function) {\n  list.forEach(fn)\n}\n","export function assert(\n  condition: unknown,\n  message: string,\n  errorTitle?: string,\n): asserts condition {\n  if (!condition)\n    throw Error(`${errorTitle ? errorTitle + ': ' : ''}${message}`)\n}\n\nexport const deprecate = (\n  condition: unknown,\n  subject: string,\n  suggestion?: string,\n  errorTitle?: string,\n) =>\n  !condition &&\n  console.error(\n    `${errorTitle ? errorTitle + ': ' : ''}${subject} is deprecated${\n      suggestion ? `, use ${suggestion} instead` : ''\n    }`,\n  )\n","import type {Node, NodeUnit, Cmd} from './index.h'\nimport {getGraph, getOwners, getLinks, getValue} from './getter'\nimport {nextNodeID} from './id'\nimport {CROSSLINK} from './tag'\nimport {regionStack} from './region'\nimport {own} from './own'\nimport {add, forEach} from './collection'\n\nexport const arrifyNodes = (\n  list: NodeUnit | Array<NodeUnit | NodeUnit[]> = [],\n): Node[] => (Array.isArray(list) ? list : [list]).flat().map(getGraph)\n\nexport function createNode({\n  node = [],\n  from,\n  source,\n  parent = from || source,\n  to,\n  target,\n  child = to || target,\n  scope = {},\n  meta = {},\n  family: familyRaw = {type: 'regular'},\n  regional,\n}: {\n  node?: Array<Cmd | false | void | null>\n  from?: NodeUnit | NodeUnit[]\n  source?: NodeUnit | NodeUnit[]\n  parent?: NodeUnit | NodeUnit[]\n  to?: NodeUnit | NodeUnit[]\n  target?: NodeUnit | NodeUnit[]\n  child?: NodeUnit | NodeUnit[]\n  scope?: {[name: string]: any}\n  meta?: {[name: string]: any}\n  family?: {\n    type?: 'regular' | 'crosslink' | 'domain'\n    links?: NodeUnit | NodeUnit[]\n    owners?: NodeUnit | Array<NodeUnit | NodeUnit[]>\n  }\n  regional?: boolean\n} = {}): Node {\n  const sources = arrifyNodes(parent)\n  const links = arrifyNodes(familyRaw.links)\n  const owners = arrifyNodes(familyRaw.owners)\n  const seq: Cmd[] = []\n  forEach(node, item => item && add(seq, item))\n  const result: Node = {\n    id: nextNodeID(),\n    seq,\n    next: arrifyNodes(child),\n    meta,\n    scope,\n    family: {\n      type: familyRaw.type || CROSSLINK,\n      links,\n      owners,\n    },\n  }\n  forEach(links, link => add(getOwners(link), result))\n  forEach(owners, owner => add(getLinks(owner), result))\n  forEach(sources, source => add(source.next, result))\n  if (regional && regionStack) {\n    own(getValue(regionStack), [result])\n  }\n  return result\n}\n","export const STORE = 'store'\nexport const EVENT = 'event'\nexport const EFFECT = 'effect'\nexport const DOMAIN = 'domain'\nexport const SCOPE = 'scope'\nexport const SAMPLER = 'sampler'\nexport const CROSSLINK = 'crosslink'\nexport const MAP = 'map'\nexport const STACK = 'stack'\nexport const VALUE = 'value'\nexport const REG_A = 'a'\n","import type {Leaf} from '../forest/index.h'\n\nimport type {Node, NodeUnit, StateRef, Stack} from './index.h'\nimport {readRef} from './stateRef'\nimport {getForkPage, getGraph, getValue} from './getter'\nimport type {Scope} from './unit.h'\nimport {add, forEach} from './collection'\n\n/** Names of priority groups */\ntype PriorityTag = 'child' | 'pure' | 'read' | 'barrier' | 'sampler' | 'effect'\n\nexport type BarrierPriorityTag = 'read' | 'barrier' | 'sampler' | 'effect'\n\n/**\n * Position in the current branch,\n * including call stack, priority type\n * and index of next step in the executed Node\n */\ntype Layer = {\n  idx: number\n  stack: Stack\n  type: PriorityTag\n  id: number\n}\n\n/** Queue as linked list or skew heap */\ntype QueueItem = {\n  /** node value */\n  v: Layer\n  /** left node. always null in queue but used in skew heap */\n  l: QueueItem | null\n  /** right node */\n  r: QueueItem | null\n}\ntype QueueBucket = {\n  first: QueueItem | null\n  last: QueueItem | null\n  size: number\n}\n\n/** Dedicated local metadata */\ntype Local = {\n  fail: boolean\n  failReason?: unknown\n  scope: {[key: string]: any}\n}\n\nlet heap: QueueItem | null = null\n\nconst merge = (a: QueueItem | null, b: QueueItem | null): QueueItem | null => {\n  if (!a) return b\n  if (!b) return a\n\n  let ret\n  if (\n    /**\n     * if both nodes has the same PriorityType\n     * and first node is created after second one\n     */\n    (a.v.type === b.v.type && a.v.id > b.v.id) ||\n    /**\n     * greater priority mean bucket of first node is executed later\n     * e.g  a: \"sampler\", b: \"barrier\"\n     */\n    getPriority(a.v.type) > getPriority(b.v.type)\n  ) {\n    ret = a\n    a = b\n    b = ret\n  }\n  ret = merge(a.r, b)\n  a.r = a.l\n  a.l = ret\n\n  return a\n}\n\n/** queue buckets for each PriorityType */\nconst queue: QueueBucket[] = []\nlet ix = 0\nwhile (ix < 6) {\n  /**\n   * although \"sampler\" and \"barrier\" are using heap instead of linked list,\n   * their buckets are still useful: they maintains size of heap queue\n   */\n  add(queue, {first: null, last: null, size: 0})\n  ix += 1\n}\n\nconst deleteMin = () => {\n  for (let i = 0; i < 6; i++) {\n    const list = queue[i]\n    if (list.size > 0) {\n      /**\n       * bucket 3 is for \"barrier\" PriorityType (used in combine)\n       * bucket 4 is for \"sampler\" PriorityType (used in sample and guard)\n       */\n      if (i === 3 || i === 4) {\n        list.size -= 1\n        const value = heap!.v\n        heap = merge(heap!.l, heap!.r)\n        return value\n      }\n      if (list.size === 1) {\n        list.last = null\n      }\n      const item = list.first\n      list.first = item!.r\n      list.size -= 1\n      return item!.v\n    }\n  }\n}\nconst pushFirstHeapItem = (\n  type: PriorityTag,\n  page: Leaf | null,\n  node: Node,\n  parent: Stack | null,\n  value: any,\n  scope?: Scope | null | void,\n  meta?: Record<string, any> | void,\n) =>\n  pushHeap(\n    0,\n    {\n      a: null,\n      b: null,\n      node,\n      parent,\n      value,\n      page,\n      scope,\n      meta,\n    },\n    type,\n    0,\n  )\nconst pushHeap = (idx: number, stack: Stack, type: PriorityTag, id: number) => {\n  const priority = getPriority(type)\n  const bucket: QueueBucket = queue[priority]\n  const item: QueueItem = {\n    v: {idx, stack, type, id},\n    l: null,\n    r: null,\n  }\n  /**\n   * bucket 3 is for \"barrier\" PriorityType (used in combine)\n   * bucket 4 is for \"sampler\" PriorityType (used in sample and guard)\n   */\n  if (priority === 3 || priority === 4) {\n    heap = merge(heap, item)\n  } else {\n    if (bucket.size === 0) {\n      bucket.first = item\n    } else {\n      bucket.last!.r = item\n    }\n    bucket.last = item\n  }\n  bucket.size += 1\n}\n\nconst getPriority = (t: PriorityTag) => {\n  switch (t) {\n    case 'child':\n      return 0\n    case 'pure':\n      return 1\n    case 'read':\n      return 2\n    case 'barrier':\n      return 3\n    case 'sampler':\n      return 4\n    case 'effect':\n      return 5\n    default:\n      return -1\n  }\n}\n\nconst barriers = new Set<string | number>()\n\nlet isRoot = true\nexport let isWatch = false\nexport let isPure = false\nexport let currentPage: Leaf | null = null\nexport let forkPage: Scope | void | null\nexport const setForkPage = (newForkPage: Scope | void | null) => {\n  forkPage = newForkPage\n}\nexport const setCurrentPage = (newPage: Leaf | null) => {\n  currentPage = newPage\n}\n\nconst getPageForRef = (page: Leaf | null, id: string) => {\n  if (page) {\n    while (page && !page.reg[id]) {\n      page = page.parent\n    }\n    if (page) return page\n  }\n  return null\n}\nexport const getPageRef = (\n  page: Leaf | null,\n  forkPage: Scope | null | void,\n  ref: StateRef,\n  isGetState: boolean,\n) => {\n  const pageForRef = getPageForRef(page, ref.id)\n  if (pageForRef) return pageForRef.reg[ref.id]\n  if (forkPage) {\n    initRefInScope(forkPage!, ref, isGetState)\n    return forkPage.reg[ref.id]\n  }\n  return ref\n}\n\n/** Introspection api internals */\ntype Inspector = (stack: Stack, local: Local) => void\nlet inspector: Inspector\nexport const setInspector = (newInspector: Inspector) => {\n  inspector = newInspector\n}\n\nexport function launch(config: {\n  target: NodeUnit | NodeUnit[]\n  params?: any\n  defer?: boolean\n  page?: Leaf | void | null\n  scope?: Scope | void | null\n  stack?: Stack | void\n  meta?: Record<string, any> | void\n}): void\nexport function launch(unit: NodeUnit, payload?: any, upsert?: boolean): void\nexport function launch(unit: any, payload?: any, upsert?: boolean) {\n  let pageForLaunch = currentPage\n  let stackForLaunch = null\n  let forkPageForLaunch = forkPage\n  let meta: Record<string, any> | void\n  if (unit.target) {\n    payload = unit.params\n    upsert = unit.defer\n    meta = unit.meta\n    pageForLaunch = 'page' in unit ? unit.page : pageForLaunch\n    if (unit.stack) stackForLaunch = unit.stack\n    forkPageForLaunch = getForkPage(unit) || forkPageForLaunch\n    unit = unit.target\n  }\n  if (forkPageForLaunch && forkPage && forkPageForLaunch !== forkPage) {\n    forkPage = null\n  }\n  if (Array.isArray(unit)) {\n    for (let i = 0; i < unit.length; i++) {\n      pushFirstHeapItem(\n        'pure',\n        pageForLaunch,\n        getGraph(unit[i]),\n        stackForLaunch,\n        payload[i],\n        forkPageForLaunch,\n        meta,\n      )\n    }\n  } else {\n    pushFirstHeapItem(\n      'pure',\n      pageForLaunch,\n      getGraph(unit),\n      stackForLaunch,\n      payload,\n      forkPageForLaunch,\n      meta,\n    )\n  }\n  if (upsert && !isRoot) return\n  /** main execution code */\n  const lastStartedState = {\n    isRoot,\n    currentPage,\n    scope: forkPage,\n    isWatch,\n    isPure,\n  }\n  isRoot = false\n  let stop: boolean\n  let skip: boolean\n  let node: Node\n  let value: Layer | undefined\n  let page: Leaf | null\n  let reg: Record<string, StateRef> | void\n  kernelLoop: while ((value = deleteMin())) {\n    const {idx, stack, type} = value\n    node = stack.node\n    currentPage = page = stack.page\n    forkPage = getForkPage(stack)\n    if (page) reg = page.reg\n    else if (forkPage) reg = forkPage.reg\n    // reg = (page ? page : forkPage ? forkPage : node).reg\n    const hasPageReg = !!page\n    const hasScopeReg = !!forkPage\n    const local: Local = {\n      fail: false,\n      scope: node.scope,\n    }\n    stop = skip = false\n    for (let stepn = idx; stepn < node.seq.length && !stop; stepn++) {\n      const step = node.seq[stepn]\n      if (step.order) {\n        const {priority, barrierID} = step.order\n        const id = barrierID\n          ? page\n            ? `${page.fullID}_${barrierID}`\n            : barrierID\n          : 0\n        if (stepn !== idx || type !== priority) {\n          if (barrierID) {\n            if (!barriers.has(id)) {\n              barriers.add(id)\n              pushHeap(stepn, stack, priority, barrierID)\n            }\n          } else {\n            pushHeap(stepn, stack, priority, 0)\n          }\n          continue kernelLoop\n        }\n        barrierID && barriers.delete(id)\n      }\n      switch (step.type) {\n        case 'mov': {\n          const data = step.data\n          let value\n          //prettier-ignore\n          switch (data.from) {\n            case 'stack': value = getValue(stack); break\n            case 'a': /** fall-through case */\n            case 'b':\n              value = stack[data.from]\n              break\n            case 'value': value = data.store; break\n            case 'store':\n              if (reg && !reg[data.store.id]) {\n                // if (!page.parent) {\n                if (hasPageReg) {\n                  const pageForRef = getPageForRef(page, data.store.id)\n                  stack.page = page = pageForRef\n                  if (pageForRef) {\n                    reg = pageForRef.reg\n                  } else if (hasScopeReg) {\n                    initRefInScope(forkPage!, data.store, false, true, data.softRead)\n                    reg = forkPage!.reg\n                  } else {\n                    reg = undefined //node.reg\n                  }\n                } else if (hasScopeReg) {\n                  /** StateRef in Scope.reg created only when needed */\n                  initRefInScope(forkPage!, data.store, false, true, data.softRead)\n                } else {\n                  // console.error('should not happen')\n                  /** StateRef should exists at least in Node itself, but it is not found */\n                }\n                // }\n              }\n              // value = getPageRef(page, forkPage, data.store.id, false).current\n              value = readRef(reg ? reg[data.store.id] || data.store : data.store)\n              break\n          }\n          //prettier-ignore\n          switch (data.to) {\n            case 'stack': stack.value = value; break\n            case 'a': /** fall-through case */\n            case 'b':\n              stack[data.to] = value\n              break\n            case 'store':\n              getPageRef(page, forkPage, data.target, false).current = value\n              break\n          }\n          break\n        }\n        case 'compute':\n          const data = step.data\n          if (data.fn) {\n            isWatch = node.meta.op === 'watch'\n            isPure = data.pure\n            const computationResult = data.safe\n              ? (0 as any, data.fn)(getValue(stack), local.scope, stack)\n              : tryRun(local, data.fn, stack)\n            if (data.filter) {\n              /**\n               * handled edge case: if step.fn will throw,\n               * tryRun will return null\n               * thereby forcing that branch to stop\n               */\n              skip = !computationResult\n            } else {\n              stack.value = computationResult\n            }\n            isWatch = lastStartedState.isWatch\n            isPure = lastStartedState.isPure\n          }\n          break\n      }\n      stop = local.fail || skip\n    }\n    if (inspector) {\n      inspector(stack, local)\n    }\n    if (!stop) {\n      const finalValue = getValue(stack)\n      const forkPage = getForkPage(stack)\n      forEach(node.next, nextNode => {\n        pushFirstHeapItem('child', page, nextNode, stack, finalValue, forkPage)\n      })\n      if (forkPage) {\n        if (node.meta.needFxCounter)\n          pushFirstHeapItem(\n            'child',\n            page,\n            forkPage.fxCount,\n            stack,\n            finalValue,\n            forkPage,\n          )\n        if (node.meta.storeChange)\n          pushFirstHeapItem(\n            'child',\n            page,\n            forkPage.storeChange,\n            stack,\n            finalValue,\n            forkPage,\n          )\n        if (node.meta.warnSerialize)\n          pushFirstHeapItem(\n            'child',\n            page,\n            forkPage.warnSerializeNode,\n            stack,\n            finalValue,\n            forkPage,\n          )\n        const additionalLinks = forkPage.additionalLinks[node.id]\n        if (additionalLinks) {\n          forEach(additionalLinks, nextNode => {\n            pushFirstHeapItem(\n              'child',\n              page,\n              nextNode,\n              stack,\n              finalValue,\n              forkPage,\n            )\n          })\n        }\n      }\n    }\n  }\n  isRoot = lastStartedState.isRoot\n  currentPage = lastStartedState.currentPage\n  forkPage = getForkPage(lastStartedState)\n}\n\nconst noopParser = (x: any) => x\n\nexport const initRefInScope = (\n  scope: Scope,\n  sourceRef: StateRef,\n  isGetState?: boolean,\n  isKernelCall?: boolean,\n  softRead?: boolean,\n) => {\n  const refsMap = scope.reg\n  if (refsMap[sourceRef.id]) return\n  const sid = sourceRef.sid\n  const ref: StateRef = {\n    id: sourceRef.id,\n    current: sourceRef.initial!,\n    meta: sourceRef.meta,\n  }\n\n  if (ref.id in scope.values.idMap) {\n    ref.current = scope.values.idMap[ref.id]\n  } else if (sid && sid in scope.values.sidMap && !(sid in scope.sidIdMap)) {\n    const serialize = sourceRef?.meta?.serialize\n    const parser =\n      scope.fromSerialize && serialize !== 'ignore'\n        ? serialize?.read || noopParser\n        : noopParser\n    ref.current = parser(scope.values.sidMap[sid])\n  } else {\n    if (sourceRef.before && !softRead) {\n      let isFresh = false\n      const needToAssign = isGetState || !sourceRef.noInit || isKernelCall\n      forEach(sourceRef.before, cmd => {\n        switch (cmd.type) {\n          case 'map': {\n            const from = cmd.from\n            if (from || cmd.fn) {\n              if (from) initRefInScope(scope, from, isGetState, isKernelCall)\n              if (needToAssign) {\n                const value = from && refsMap[from.id].current\n                ref.current = cmd.fn ? cmd.fn(value) : value\n              }\n            }\n            break\n          }\n          case 'field': {\n            initRefInScope(scope, cmd.from, isGetState, isKernelCall)\n            if (!isFresh) {\n              isFresh = true\n              if (Array.isArray(ref.current)) {\n                ref.current = [...ref.current]\n              } else {\n                ref.current = {...ref.current}\n              }\n            }\n            if (needToAssign) {\n              const from = refsMap[cmd.from.id]\n              ref.current[cmd.field] = refsMap[from.id].current\n            }\n            break\n          }\n          // case 'closure':\n          //   break\n        }\n      })\n    }\n  }\n  if (sid) scope.sidIdMap[sid] = sourceRef.id\n  refsMap[sourceRef.id] = ref\n}\n\n/** try catch for external functions */\nconst tryRun = (local: Local, fn: Function, stack: Stack) => {\n  try {\n    return fn(getValue(stack), local.scope, stack)\n  } catch (err) {\n    console.error(err)\n    local.fail = true\n    local.failReason = err\n  }\n}\n","import type {Store, CommonUnit, Domain} from './unit.h'\nimport {is} from './is'\nimport {getParent, getCompositeName} from './getter'\nimport {forIn} from './collection'\n\nexport function unitObjectName(objOrArr: any, method: string = 'combine') {\n  let name = method + '('\n  let comma = ''\n  let i = 0\n  forIn(objOrArr, unit => {\n    /* inlined max object names constant */\n    if (i < 25) {\n      if (unit != null) {\n        name += comma\n        name += is.unit(unit)\n          ? getCompositeName(unit as CommonUnit | Domain).fullName\n          : (unit as any).toString()\n      }\n      i += 1\n      comma = ', '\n    }\n  })\n  return name + ')'\n}\n\nexport function setStoreName<State>(store: Store<State>, rawName: string) {\n  store.shortName = rawName\n  Object.assign(getCompositeName(store), createName(rawName, getParent(store)))\n}\n\nexport type CompositeName = {\n  shortName: string\n  fullName: string\n  path: string[]\n}\n\nexport function createName(name: string, parent?: Domain): CompositeName {\n  let path: string[]\n  let fullName\n  const shortName = name\n  if (!parent) {\n    path = name.length === 0 ? [] : [name]\n    fullName = name\n  } else {\n    const composite = getCompositeName(parent)\n    if (name.length === 0) {\n      path = composite.path\n      fullName = composite.fullName\n    } else {\n      path = composite.path.concat([name])\n      fullName =\n        composite.fullName.length === 0\n          ? name\n          : '' + composite.fullName + '/' + name\n    }\n  }\n  return {shortName, fullName, path}\n}\n\nexport function generateErrorTitle(method: string, metadata: any) {\n  if (!metadata) return method\n  if (!metadata.name && !metadata.named && !metadata.loc) return method\n  let result = `[${method}]`\n  const name = metadata.named || metadata.name\n  if (name) {\n    result += ` unit '${name}'`\n  }\n  const loc = metadata.loc\n  if (!name && loc) {\n    result += ` (${loc.file}:${loc.line}:${loc.column})`\n  }\n  return result\n}\n","import {forIn} from './collection'\nimport {assertObject, isObject, isVoid} from './is'\n\nexport function processArgsToConfig(\n  arg: any,\n  singleArgument: true,\n): [any, any | void]\nexport function processArgsToConfig(args: any[]): [any[], any | void]\nexport function processArgsToConfig(\n  args: any[],\n  singleArgument?: boolean,\n): [any[], any | void] {\n  const rawConfig = singleArgument ? args : args[0]\n  assertObject(rawConfig)\n  let metadata = rawConfig.or\n  const childConfig = rawConfig.and\n  if (childConfig) {\n    const unwrappedNestedValue = singleArgument ? childConfig : childConfig[0]\n    /**\n     * if there is no \"and\" field then we reached the leaf of the tree\n     * and this is an original user-defined argument\n     *\n     * note that in this case we're returning all arguments, not the only one been unwrapped\n     **/\n    if (!isObject(unwrappedNestedValue) || !('and' in unwrappedNestedValue)) {\n      args = childConfig\n    } else {\n      //@ts-expect-error\n      const nested = processArgsToConfig(childConfig, singleArgument)\n\n      args = nested[0]\n      metadata = {...metadata, ...nested[1]}\n    }\n  }\n  return [args, metadata]\n}\n\n/**\nprocessed fields:\n\n'name',\n'sid',\n'loc',\n'handler',\n'updateFilter',\n'parent',\n'serialize',\n'named',\n'derived',\n*/\nexport const flattenConfig = (part: any, config: Record<string, any> = {}) => {\n  if (isObject(part)) {\n    flattenConfig(part.or, config)\n    forIn(part, (value, field) => {\n      if (!isVoid(value) && field !== 'or' && field !== 'and') {\n        config[field] = value\n      }\n    })\n    flattenConfig(part.and, config)\n  }\n  return config\n}\n","import type {Subscription, NodeUnit} from './index.h'\nimport {clearNode} from './clearNode'\n\nexport const createSubscription = (node: NodeUnit): Subscription =>\n  addUnsubscribe(() => clearNode(node))\n\nexport function addUnsubscribe(callback: () => void): Subscription {\n  const subscription: Subscription = () => callback()\n  subscription.unsubscribe = () => callback()\n\n  return subscription\n}\n","import {readTemplate} from './region'\nimport type {Template, TemplateHandlers} from '../forest/index.h'\n\nexport function applyTemplate<K extends keyof TemplateHandlers>(\n  method: K,\n  ...args: Parameters<TemplateHandlers[K]> extends [Template, ...infer Args]\n    ? Args\n    : never\n): ReturnType<TemplateHandlers[K]> | void {\n  const template = readTemplate()\n  if (template) {\n    const fn = template.handlers[method]\n    // @ts-expect-error\n    if (fn) return fn(template, ...args)\n  }\n}\n","import type {Template} from '../forest/index.h'\nimport type {Store, Event, CommonUnit, Effect, Domain} from './unit.h'\nimport type {Subscriber, Config, Cmd, Kind} from './index.h'\n\nimport {observableSymbol} from './observable'\n\nimport {\n  is,\n  isObject,\n  isFunction,\n  assertObject,\n  assertNodeSet,\n  isVoid,\n} from './is'\nimport {calc, mov, read, userFnCall} from './step'\nimport {createStateRef, readRef, addRefOp} from './stateRef'\nimport {nextUnitID} from './id'\nimport {callStackAReg, callARegStack, callStack} from './caller'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {\n  launch,\n  currentPage,\n  forkPage,\n  setCurrentPage,\n  initRefInScope,\n  isPure,\n} from './kernel'\n\nimport {createName, generateErrorTitle} from './naming'\nimport {createLinkNode} from './forward'\nimport {watchUnit} from './watch'\nimport {createSubscription} from './subscription'\nimport {readTemplate, readSidRoot, reportDeclaration} from './region'\nimport {\n  getSubscribers,\n  getStoreState,\n  getGraph,\n  getParent,\n  setMeta,\n  getMeta,\n} from './getter'\nimport {assert, deprecate} from './throw'\nimport {DOMAIN, STORE, EVENT, MAP, STACK, REG_A} from './tag'\nimport {applyTemplate} from './template'\nimport {forEach} from './collection'\nimport {flattenConfig} from './config'\n\nexport const applyParentHook = (\n  source: CommonUnit,\n  target: CommonUnit,\n  hookType: 'event' | 'effect' = EVENT,\n) => {\n  if (getParent(source)) getParent(source).hooks[hookType](target)\n}\n\nexport const initUnit = (kind: Kind, unit: any, rawConfig: any) => {\n  const config = flattenConfig(rawConfig)\n  const isDomain = kind === DOMAIN\n  const id = nextUnitID()\n  const {sid = null, named = null, domain = null, parent = domain} = config\n  const name = named ? named : config.name || (isDomain ? '' : id)\n  const compositeName = createName(name, parent)\n  const meta: Record<string, any> = {\n    op: (unit.kind = kind),\n    name: (unit.shortName = name),\n    sid: (unit.sid = readSidRoot(sid)),\n    named,\n    unitId: (unit.id = id),\n    serialize: config.serialize,\n    derived: config.derived,\n    config,\n  }\n  unit.targetable = !config.derived\n  unit.parent = parent\n  unit.compositeName = compositeName\n  unit.defaultConfig = config\n  unit.getType = () => {\n    deprecate(false, 'getType', 'compositeName.fullName')\n    return compositeName.fullName\n  }\n  if (!isDomain) {\n    unit.subscribe = (observer: Subscriber<any>) => {\n      assertObject(observer)\n      return unit.watch(\n        isFunction(observer)\n          ? observer\n          : (upd: any) => observer.next && observer.next(upd),\n      )\n    }\n    unit[observableSymbol] = () => unit\n    const template = readTemplate()\n    if (template) meta.nativeTemplate = template\n  }\n  return meta\n}\nexport const createNamedEvent = (named: string) => createEvent({named})\n\nconst deriveEvent = (\n  event: Event<any>,\n  op: 'map' | 'filterMap' | 'filter',\n  fn: Function,\n  node: Cmd[],\n) => {\n  let config\n  if (isObject(fn)) {\n    config = fn\n    fn = (fn as unknown as {fn: Function}).fn\n  }\n  const mapped = createEvent({\n    name: `${event.shortName} → *`,\n    derived: true,\n    and: config,\n  })\n  createLinkNode(event, mapped, node, op, fn)\n  return mapped\n}\n\nfunction callCreate<T>(\n  unit: Event<T> | Effect<T, any, any>,\n  template: Template | null,\n  payload: T,\n  args: any[],\n) {\n  const oldPage = currentPage\n  let page = null\n  if (template) {\n    page = currentPage\n    while (page && page.template !== template) {\n      page = getParent(page)\n    }\n  }\n  setCurrentPage(page)\n  const result = unit.create(payload, args)\n  setCurrentPage(oldPage)\n  return result\n}\n\nexport function createEvent<Payload = any>(\n  nameOrConfig?: any,\n  maybeConfig?: any,\n): Event<Payload> {\n  const config = flattenConfig({\n    or: maybeConfig,\n    and: typeof nameOrConfig === 'string' ? {name: nameOrConfig} : nameOrConfig,\n  }) as any\n  const errorTitle = generateErrorTitle('event', config)\n  const event = ((payload: Payload, ...args: unknown[]) => {\n    assert(\n      !getMeta(event, 'derived'),\n      'call of derived event is not supported, use createEvent instead',\n      errorTitle,\n    )\n    assert(\n      !isPure,\n      'unit call from pure function is not supported, use operators like sample instead',\n      errorTitle,\n    )\n    if (currentPage) {\n      return callCreate(event, template, payload, args)\n    }\n    return event.create(payload, args)\n  }) as Event<Payload>\n  const template = readTemplate()\n  const finalEvent = Object.assign(event, {\n    graphite: createNode({\n      meta: initUnit(config.actualOp || EVENT, event, config),\n      regional: true,\n    }),\n    create(params: Payload, _: any[]) {\n      launch({target: event, params, scope: forkPage!})\n      return params\n    },\n    watch: (fn: (payload: Payload) => any) => watchUnit(event, fn),\n    map: (fn: Function) => deriveEvent(event, MAP, fn, [userFnCall()]),\n    filter: (fn: {fn: Function}) =>\n      //@ts-expect-error\n      deriveEvent(event, 'filter', fn.fn ? fn : fn.fn, [\n        userFnCall(callStack, true),\n      ]),\n    filterMap: (fn: Function) =>\n      deriveEvent(event, 'filterMap', fn, [\n        userFnCall(),\n        calc(value => !isVoid(value), true),\n      ]),\n    prepend(fn: Function) {\n      assert(\n        // @ts-expect-error\n        event.targetable,\n        '.prepend of derived event is not supported, call source event instead',\n        errorTitle,\n      )\n      const contramapped: Event<any> = createEvent('* → ' + event.shortName, {\n        parent: getParent(event),\n      })\n      applyTemplate('eventPrepend', getGraph(contramapped))\n      createLinkNode(contramapped, event, [userFnCall()], 'prepend', fn)\n      applyParentHook(event, contramapped)\n      return contramapped\n    },\n  })\n  if (config?.domain) {\n    config.domain.hooks.event(finalEvent)\n  }\n  setMeta(finalEvent, 'id', finalEvent.graphite.id)\n  reportDeclaration(finalEvent.graphite)\n  return finalEvent\n}\nfunction on<State>(\n  store: Store<State>,\n  methodName: string,\n  nodeSet: CommonUnit | CommonUnit[],\n  fn: Function,\n  errorTitle: string,\n) {\n  assertNodeSet(nodeSet, `${errorTitle} ${methodName}`, 'first argument')\n  assert(isFunction(fn), 'second argument should be a function', errorTitle)\n  deprecate(\n    !getMeta(store, 'derived'),\n    `${methodName} in derived store`,\n    `${methodName} in store created via createStore`,\n    errorTitle,\n  )\n  forEach(Array.isArray(nodeSet) ? nodeSet : [nodeSet], trigger => {\n    store.off(trigger)\n    getSubscribers(store).set(\n      trigger,\n      createSubscription(updateStore(trigger, store, 'on', callARegStack, fn)),\n    )\n  })\n  return store\n}\n\nexport const requireExplicitSkipVoidMessage =\n  'undefined is used to skip updates. To allow undefined as a value provide explicit { skipVoid: false } option'\n\nexport function createStore<State>(\n  defaultState: State,\n  props?: Config,\n): Store<State> {\n  const config = flattenConfig(props)\n  const plainState = createStateRef(defaultState)\n  const errorTitle = generateErrorTitle('store', config)\n  const updates = createEvent({named: 'updates', derived: true})\n  applyTemplate('storeBase', plainState)\n  const plainStateId = plainState.id\n\n  // skipVoid deprecation rules\n  const explicitSkipVoid = 'skipVoid' in config\n  const voidValueAllowed = explicitSkipVoid && !config.skipVoid\n  const skipVoidTrueSet = explicitSkipVoid && config.skipVoid\n\n  deprecate(!skipVoidTrueSet, '{skipVoid: true}', 'updateFilter', errorTitle)\n\n  const store = {\n    subscribers: new Map(),\n    updates,\n    defaultState,\n    stateRef: plainState,\n    getState() {\n      let targetRef = plainState\n      let reachedPage\n      if (currentPage) {\n        let page = currentPage\n        while (page && !page.reg[plainStateId]) {\n          page = getParent(page)\n        }\n        if (page) reachedPage = page\n      }\n      if (!reachedPage && forkPage) {\n        initRefInScope(forkPage, plainState, true)\n        reachedPage = forkPage\n      }\n      if (reachedPage) targetRef = reachedPage.reg[plainStateId]\n      return readRef(targetRef)\n    },\n    setState: (state: State) =>\n      launch({\n        target: store,\n        params: state,\n        defer: true,\n        scope: forkPage!,\n      }),\n    reset(...units: CommonUnit[]) {\n      assert(\n        // @ts-expect-error\n        store.targetable,\n        '.reset of derived store is not supported',\n        errorTitle,\n      )\n      forEach(units, unit =>\n        on(store, '.reset', unit, () => store.defaultState, errorTitle),\n      )\n      return store\n    },\n    on(nodeSet: CommonUnit | CommonUnit[], fn: Function) {\n      assert(\n        // @ts-expect-error\n        store.targetable,\n        '.on of derived store is not supported',\n        errorTitle,\n      )\n      return on(store, '.on', nodeSet, fn, errorTitle)\n    },\n    off(unit: CommonUnit) {\n      const currentSubscription = getSubscribers(store).get(unit)\n      if (currentSubscription) {\n        currentSubscription()\n        getSubscribers(store).delete(unit)\n      }\n      return store\n    },\n    map(fn: (value: any) => any, outerConfig: Config) {\n      let mapConfig: Config | undefined\n      if (isObject(fn)) {\n        mapConfig = fn as any\n        fn = (fn as unknown as {fn: (value: any) => any}).fn\n      }\n      let lastResult\n      const storeState = store.getState()\n      const parentStateVoid = isVoid(storeState)\n      const template = readTemplate()\n      if (template) {\n        lastResult = null\n      } else if (!parentStateVoid || (parentStateVoid && voidValueAllowed)) {\n        lastResult = fn(storeState)\n      }\n\n      const innerStore: Store<any> = createStore(lastResult, {\n        name: `${store.shortName} → *`,\n        derived: true,\n        ...outerConfig,\n        and: mapConfig,\n      })\n      const linkNode = updateStore(store, innerStore, MAP, callStack, fn)\n      addRefOp(getStoreState(innerStore), {\n        type: MAP,\n        fn,\n        from: plainState,\n      })\n      getStoreState(innerStore).noInit = true\n      applyTemplate('storeMap', plainState, linkNode)\n      return innerStore\n    },\n    watch(eventOrFn: any, fn?: Function) {\n      deprecate(!fn, 'watch second argument', 'sample', errorTitle)\n      if (!fn || !is.unit(eventOrFn)) {\n        const subscription = watchUnit(store, eventOrFn)\n        if (!applyTemplate('storeWatch', plainState, eventOrFn)) {\n          eventOrFn(store.getState())\n        }\n        return subscription\n      }\n      assert(isFunction(fn), 'second argument should be a function', errorTitle)\n      return (eventOrFn as CommonUnit).watch((payload: any) =>\n        fn(store.getState(), payload),\n      )\n    },\n  } as unknown as Store<State>\n  const meta = initUnit(STORE, store, config)\n  const updateFilter = store.defaultConfig.updateFilter\n  store.graphite = createNode({\n    scope: {state: plainState, fn: updateFilter},\n    node: [\n      calc((upd, _, stack) => {\n        if (stack.scope && !stack.scope.reg[plainState.id]) {\n          stack.b = true\n        }\n        return upd\n      }),\n      read(plainState),\n      calc((upd, _, {a, b}) => {\n        const isVoidUpdate = isVoid(upd)\n\n        if (isVoidUpdate && !explicitSkipVoid) {\n          console.error(`${errorTitle}: ${requireExplicitSkipVoidMessage}`)\n        }\n\n        return (\n          ((isVoidUpdate && voidValueAllowed) || !isVoidUpdate) &&\n          (upd !== a || b)\n        )\n      }, true),\n      updateFilter && userFnCall(callStackAReg, true),\n      mov({from: STACK, target: plainState}),\n    ],\n    child: updates,\n    meta: {\n      ...meta,\n      defaultState,\n    },\n    regional: true,\n  })\n  setMeta(store, 'id', store.graphite.id)\n  setMeta(store, 'rootStateRefId', plainStateId)\n  const serializeMeta = getMeta(store, 'serialize')\n  const derived = getMeta(store, 'derived')\n  const ignored = serializeMeta === 'ignore'\n  const sid: string | null = getMeta(store, 'sid')\n  if (sid) {\n    setMeta(store, 'storeChange', true)\n    plainState.sid = sid\n  }\n  if (!sid && !ignored && !derived) {\n    setMeta(store, 'warnSerialize', true)\n  }\n  const isVoidDefaultState = isVoid(defaultState)\n  const canVoid = isVoidDefaultState && voidValueAllowed\n  assert(\n    derived || !isVoidDefaultState || canVoid,\n    requireExplicitSkipVoidMessage,\n    errorTitle,\n  )\n  if (derived && isVoidDefaultState && !explicitSkipVoid) {\n    console.error(`${errorTitle}: ${requireExplicitSkipVoidMessage}`)\n  }\n  own(store, [updates])\n  if (config?.domain) {\n    config.domain.hooks.store(store)\n  }\n\n  if (!derived) {\n    store.reinit = createEvent<void>({\n      named: 'reinit',\n    })\n    store.reset(store.reinit)\n  }\n\n  plainState.meta = store.graphite.meta\n\n  reportDeclaration(store.graphite)\n\n  return store\n}\n\nconst updateStore = (\n  from: CommonUnit,\n  store: Store<any>,\n  op: string,\n  caller: typeof callStackAReg,\n  fn: Function,\n) => {\n  const storeRef = getStoreState(store)\n  const reader = mov({\n    store: storeRef,\n    to: REG_A,\n    priority: 'read',\n  })\n  /**\n   * Store reading is not needed for store.map anymore\n   * but there is a fine tuning of \"wire lengths\"\n   * lack of which leads to a lot of reordering and retriggering issues\n   **/\n  if (op === MAP) reader.data.softRead = true\n  const node = [reader, userFnCall(caller)]\n  applyTemplate(\n    'storeOnMap',\n    storeRef,\n    node,\n    is.store(from) && getStoreState(from),\n  )\n  return createLinkNode(from, store, node, op, fn)\n}\n","import type {Store} from './unit.h'\nimport {createStore, requireExplicitSkipVoidMessage} from './createUnit'\nimport {createStateRef, addRefOp} from './stateRef'\nimport {mov, calc, read, userFnCall} from './step'\nimport {processArgsToConfig} from './config'\nimport {getStoreState, setMeta} from './getter'\nimport {is, isFunction, isObject, isVoid} from './is'\nimport {generateErrorTitle, unitObjectName} from './naming'\nimport {createLinkNode} from './forward'\nimport {assert, deprecate} from './throw'\nimport {readTemplate} from './region'\nimport {forIn} from './collection'\nimport {MAP, REG_A, VALUE} from './tag'\nimport {applyTemplate} from './template'\nimport type {Config} from './index.h'\n\nexport function combine(...args: any[]): Store<any> {\n  let handler\n  let stores\n  let config\n  ;[args, config] = processArgsToConfig(args)\n  const errorTitle = generateErrorTitle('combine', config)\n  // skipVoid support, to be removed in effector 24\n  const maybeExtConfig = args[args.length - 1]\n  /**\n   * if there only one argument then it's a store or object with stores\n   * else if last argument is a store, then its `combine($foo, $bar)`\n   * else if last argument is not an object, then it's a handler\n   * else it's a config object\n   */\n  const isExtendedConfig =\n    args.length > 1 && !is.store(maybeExtConfig) && isObject(maybeExtConfig)\n  const extConfig = isExtendedConfig && maybeExtConfig\n  const rawHandler = isExtendedConfig ? args[args.length - 2] : maybeExtConfig\n  if (isFunction(rawHandler)) {\n    stores = args.slice(0, isExtendedConfig ? -2 : -1)\n    handler = rawHandler\n  } else {\n    stores = args\n  }\n\n  let structStoreShape\n  let shapeReady\n  if (stores.length === 1) {\n    const obj = stores[0]\n    /*\n      without edge case combine(Color, (Color) => '~')\n      */\n    if (!is.store(obj)) {\n      /*\n      case combine([R,G,B], ([R,G,B]) => '~')\n      case combine({R,G,B}, ({R,G,B}) => '~')\n\n      edge case combine([Color], ([Color]) => '~')\n      edge case combine({Color}, ({Color}) => '~')\n\n      edge case combine([R,G,B])\n      edge case combine({R,G,B})\n\n      edge case combine([Color])\n      edge case combine({Color})\n      */\n      structStoreShape = obj\n      shapeReady = true\n    }\n  }\n  let noArraySpread: boolean | undefined\n  if (!shapeReady) {\n    /*\n    case combine(R,G,B, (R,G,B) => '~')\n    */\n    structStoreShape = stores\n    /*\n    without edge case combine(R,G,B)\n    without edge case combine(Color)\n    */\n    if (handler) {\n      noArraySpread = true\n      const fn = handler\n      handler = (list: any[]) => fn(...list)\n    }\n  }\n  assert(isObject(structStoreShape), `${errorTitle}: shape should be an object`)\n  return storeCombination(\n    Array.isArray(structStoreShape),\n    !noArraySpread,\n    structStoreShape,\n    config,\n    handler,\n    extConfig,\n  )\n}\n\nconst storeCombination = (\n  isArray: boolean,\n  needSpread: boolean,\n  obj: any,\n  config?: Config,\n  fn?: (upd: any) => any,\n  extConfig?: false | {skipVoid?: boolean},\n) => {\n  const errorTitle = generateErrorTitle('combine', config)\n  const clone = isArray ? (list: any) => [...list] : (obj: any) => ({...obj})\n  const defaultState: Record<string, any> = isArray ? [] : {}\n\n  const stateNew = clone(defaultState)\n  const rawShape = createStateRef(stateNew)\n  const isFresh = createStateRef(true)\n  rawShape.type = isArray ? 'list' : 'shape'\n  rawShape.noInit = true\n  applyTemplate('combineBase', rawShape, isFresh)\n  const store = createStore(stateNew, {\n    name: unitObjectName(obj),\n    derived: true,\n    ...extConfig,\n    and: config,\n  })\n  const storeStateRef = getStoreState(store)\n  storeStateRef.noInit = true\n  setMeta(store, 'isCombine', true)\n  const rawShapeReader = read(rawShape)\n  /**\n   * usual ref reading has very high priority, which leads to data races\n   * ref reading for combine should have same \"barrier\" priority but without batching\n   * (thats why order has no \"barrierID\" field, which assume batching)\n   **/\n  rawShapeReader.order = {priority: 'barrier'}\n  /**\n   * Soft store reading is required for\n   * setting target store as inited in scope\n   * for preventing retriggering issues\n   **/\n  const softReader = mov({\n    store: storeStateRef,\n    to: 'b',\n    priority: 'read',\n  })\n  softReader.data.softRead = true\n  const node = [\n    calc((upd, _, stack) => {\n      if (stack.scope && !stack.scope.reg[rawShape.id]) {\n        stack.c = true\n      }\n      return upd\n    }),\n    rawShapeReader,\n    mov({store: isFresh, to: 'b'}),\n    calc((upd, {key}, reg) => {\n      if (reg.c || upd !== reg.a[key]) {\n        if (needSpread && reg.b) {\n          reg.a = clone(reg.a)\n        }\n        reg.a[key] = upd\n        return true\n      }\n    }, true),\n    mov({from: REG_A, target: rawShape}),\n    mov({from: VALUE, store: false, target: isFresh}),\n    mov({\n      from: VALUE,\n      store: true,\n      target: isFresh,\n      priority: 'barrier',\n      batch: true,\n    }),\n    /**\n     * `read` with `sampler` priority is used to prevent cases,\n     *  where `combine` triggers are duplicated\n     *\n     *  basically, this makes `sample` and `combine` priorities equal\n     */\n    read(rawShape, true, true),\n    fn && userFnCall(),\n    softReader,\n  ]\n  forIn(obj, (child: Store<any> | any, key) => {\n    if (!is.store(child)) {\n      assert(\n        !is.unit(child) && !isVoid(child),\n        `combine expects a store in a field ${key}`,\n        errorTitle,\n      )\n      stateNew[key] = defaultState[key] = child\n      return\n    }\n    defaultState[key] = child.defaultState\n    stateNew[key] = child.getState()\n    const linkNode = createLinkNode(child, store, node, 'combine', fn)\n    linkNode.scope.key = key\n    const childRef = getStoreState(child)\n    addRefOp(rawShape, {type: 'field', field: key, from: childRef})\n    applyTemplate('combineField', childRef, linkNode)\n  })\n\n  store.defaultShape = obj\n  addRefOp(storeStateRef, {\n    type: MAP,\n    from: rawShape,\n    fn,\n  })\n  if (!readTemplate()) {\n    if (fn) {\n      const computedValue = fn(stateNew)\n\n      if (isVoid(computedValue) && (!extConfig || !('skipVoid' in extConfig))) {\n        console.error(`${errorTitle}: ${requireExplicitSkipVoidMessage}`)\n      }\n\n      storeStateRef.current = computedValue\n      storeStateRef.initial = computedValue\n      store.defaultState = computedValue\n    } else {\n      store.defaultState = defaultState\n    }\n  }\n  return store\n}\n","import type {Defer} from './unit.h'\n\nexport function createDefer(): Defer {\n  const result = {} as Defer\n  result.req = new Promise((rs, rj) => {\n    result.rs = rs\n    result.rj = rj\n  })\n  result.req.catch(() => {})\n  return result\n}\n","import type {Unit, Stack} from './index.h'\nimport type {Effect, Scope} from './unit.h'\nimport {calc, run} from './step'\nimport {getForkPage, getGraph, getMeta, getParent, setMeta} from './getter'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch, setForkPage, forkPage, isWatch} from './kernel'\nimport {createStore, createEvent} from './createUnit'\nimport {createDefer} from './defer'\nimport {isObject, isFunction} from './is'\nimport {assert} from './throw'\nimport {EFFECT} from './tag'\nimport {add} from './collection'\nimport {flattenConfig} from './config'\nimport {nextEffectID} from './id'\nimport {generateErrorTitle} from './naming'\n\ntype RunnerData<Params, Done, Fail> = {\n  params: Params\n  req: {\n    rs(data: Done): void\n    rj(data: Fail): void\n  }\n  args?: [params: Params, computedParams: any] | [params: Params]\n  handler?: Function\n}\n\nexport function createEffect<Params, Done, Fail = Error>(\n  nameOrConfig: any,\n  maybeConfig: any = {},\n): Effect<Params, Done, Fail> {\n  const config = flattenConfig(\n    isFunction(nameOrConfig) ? {handler: nameOrConfig} : nameOrConfig,\n    maybeConfig,\n  )\n  const errorTitle = generateErrorTitle('effect', config)\n  const instance = createEvent(\n    isFunction(nameOrConfig) ? {handler: nameOrConfig} : nameOrConfig,\n    {...maybeConfig, actualOp: EFFECT},\n  ) as unknown as Effect<Params, Done, Fail>\n  const node = getGraph(instance)\n  setMeta(node, 'op', (instance.kind = EFFECT))\n  //@ts-expect-error\n  instance.use = (fn: Function) => {\n    assert(isFunction(fn), '.use argument should be a function', errorTitle)\n    runner.scope.handler = fn\n    return instance\n  }\n  instance.use.getCurrent = () => runner.scope.handler\n  const anyway = (instance.finally = createEvent({\n    named: 'finally',\n    derived: true,\n  }))\n  const done = (instance.done = (anyway as any).filterMap({\n    named: 'done',\n    fn({\n      status,\n      params,\n      result,\n    }: {\n      status: 'done' | 'fail'\n      params: Params\n      result: Done\n      error: Fail\n    }) {\n      if (status === 'done') return {params, result}\n    },\n  }))\n  const fail = (instance.fail = (anyway as any).filterMap({\n    named: 'fail',\n    fn({\n      status,\n      params,\n      error,\n    }: {\n      status: 'done' | 'fail'\n      params: Params\n      result: Done\n      error: Fail\n    }) {\n      if (status === 'fail') return {params, error}\n    },\n  }))\n  const doneData = (instance.doneData = done.map({\n    named: 'doneData',\n    fn: ({result}: {result: Done}) => result,\n  }))\n  const failData = (instance.failData = fail.map({\n    named: 'failData',\n    fn: ({error}: {error: Fail}) => error,\n  }))\n\n  const runner = createNode({\n    scope: {\n      handler:\n        instance.defaultConfig.handler ||\n        (() =>\n          assert(\n            false,\n            `no handler used in ${instance.compositeName.fullName}`,\n          )),\n    },\n    node: [\n      calc(\n        (upd: RunnerData<Params, Done, Fail>, scope_: any, stack) => {\n          let handler: Function = scope_.handler\n          const scope = getForkPage(stack)\n          if (scope) {\n            const scopeHandler =\n              scope.handlers.unitMap.get(instance) ||\n              scope.handlers.sidMap[instance.sid!]\n            if (scopeHandler) handler = scopeHandler\n          }\n          upd.handler = handler\n          return upd\n        },\n        false,\n        true,\n      ),\n      calc(\n        (\n          upd: RunnerData<Params, Done, Fail> & {handler: Function},\n          _,\n          stack,\n        ) => {\n          if (_.runnerFn) {\n            const needToContinue = _.runnerFn(upd, null, stack)\n            if (!needToContinue) return\n          }\n          /** upd.args could be changed by runnerFn */\n          const {params, req, handler, args = [params]} = upd\n          const onResolve = onSettled(params, req, true, anyway, stack)\n          const onReject = onSettled(params, req, false, anyway, stack)\n          const [ok, result] = runFn(handler, onReject, args)\n          if (ok) {\n            if (isObject(result) && isFunction(result.then)) {\n              result.then(onResolve, onReject)\n            } else {\n              onResolve(result)\n            }\n          }\n        },\n        false,\n        true,\n      ),\n    ],\n    meta: {op: 'fx', fx: 'runner'},\n  })\n  node.scope.runner = runner\n  add(\n    node.seq,\n    calc((params, {runner}, stack) => {\n      const upd: RunnerData<Params, Done, Fail> = getParent(stack)\n        ? {params, req: {rs(data: Done) {}, rj(data: Fail) {}}}\n        : /** empty stack means that this node was launched directly */\n          params\n      if (!stack.meta) {\n        stack.meta = {fxID: nextEffectID()}\n      }\n      launch({\n        target: runner,\n        params: upd,\n        defer: true,\n        scope: getForkPage(stack),\n        meta: stack.meta,\n      })\n      return upd.params\n    }),\n  )\n  //@ts-expect-error\n  instance.create = (params: Params) => {\n    const req = createDefer()\n    const payload = {params, req}\n    if (forkPage) {\n      if (!isWatch) {\n        const savedFork = forkPage\n        req.req\n          .finally(() => {\n            setForkPage(savedFork)\n          })\n          .catch(() => {})\n      }\n    }\n    launch({\n      target: instance,\n      params: payload,\n      scope: forkPage,\n    })\n    return req.req\n  }\n\n  const inFlight = (instance.inFlight = createStore(0, {\n    serialize: 'ignore',\n    named: (getMeta(instance, 'name') || instance.graphite.id) + '.inFlight',\n  })\n    .on(instance, x => x + 1)\n    .on(anyway, x => x - 1)\n    .map({\n      // @ts-expect-error\n      fn: x => x,\n      named: 'inFlight',\n    }))\n  setMeta(anyway, 'needFxCounter', 'dec')\n  setMeta(instance, 'needFxCounter', true)\n  const pending = (instance.pending = inFlight.map({\n    //@ts-expect-error\n    fn: amount => amount > 0,\n    named: 'pending',\n  }))\n\n  own(instance, [anyway, done, fail, doneData, failData, pending, inFlight])\n  if (config?.domain) {\n    config.domain.hooks.effect(instance)\n  }\n  return instance\n}\nexport const runFn = (\n  fn: Function,\n  onReject: (data: any) => void,\n  args: any[],\n): [boolean, any] => {\n  try {\n    return [true, fn(...args)]\n  } catch (err) {\n    onReject(err)\n    return [false, null]\n  }\n}\n\nexport const onSettled =\n  (\n    params: any,\n    req: {\n      rs(_: any): void\n      rj(_: any): void\n    },\n    ok: boolean,\n    anyway: Unit,\n    stack: Stack,\n  ) =>\n  (data: any) => {\n    launch({\n      target: [anyway, sidechain],\n      params: [\n        ok\n          ? {status: 'done', params, result: data}\n          : {status: 'fail', params, error: data},\n        {value: data, fn: ok ? req.rs : req.rj},\n      ],\n      defer: true,\n      // WARN! Will broke forest pages as they arent moved to new scope\n      page: stack.page,\n      scope: stack.scope,\n      meta: stack.meta,\n    })\n  }\nconst sidechain = createNode({\n  node: [run({fn: ({fn, value}) => fn(value)})],\n  meta: {op: 'fx', fx: 'sidechain'},\n})\n","import type {Store, Event, Effect} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {createLinkNode} from './forward'\nimport {generateErrorTitle, unitObjectName} from './naming'\nimport {assertNodeSet} from './is'\n\nexport function merge<T>(\n  units: Array<Event<T> | Store<T> | Effect<T, any, any>>,\n  config?: object,\n): Event<T> {\n  const errorTitle = generateErrorTitle('merge', config)\n  assertNodeSet(units, errorTitle, 'first argument')\n  const result = createEvent({\n    name: unitObjectName(units, 'merge'),\n    derived: true,\n    and: config,\n  })\n  createLinkNode(units, result, [], 'merge')\n  return result\n}\n","import type {Cmd, StateRef} from './index.h'\nimport type {CommonUnit, DataCarrier} from './unit.h'\nimport {combine} from './combine'\nimport {mov, userFnCall, read, calc} from './step'\nimport {createStateRef, readRef} from './stateRef'\nimport {callStackAReg} from './caller'\nimport {processArgsToConfig} from './config'\nimport {getStoreState, getGraph} from './getter'\nimport {\n  assertNodeSet,\n  assertTarget,\n  is,\n  isObject,\n  isVoid,\n  isFunction,\n} from './is'\nimport {createStore} from './createUnit'\nimport {createEvent} from './createUnit'\nimport {createNode} from './createNode'\nimport {assert, deprecate} from './throw'\nimport {forEach} from './collection'\nimport {STACK, VALUE} from './tag'\nimport {merge} from './merge'\nimport {applyTemplate} from './template'\nimport {own} from './own'\nimport {createLinkNode} from './forward'\nimport {generateErrorTitle} from './naming'\n\nconst sampleConfigFields = ['source', 'clock', 'target']\n\nconst fieldErrorMessage = (method: string, field: string) =>\n  method + `: ${field} should be defined`\n\nexport function validateSampleConfig(config: any, method: string) {\n  let atLeastOneFieldExists = false\n  forEach(sampleConfigFields, field => {\n    if (field in config) {\n      assert(config[field] != null, fieldErrorMessage(method, field))\n      atLeastOneFieldExists = true\n    }\n  })\n  return atLeastOneFieldExists\n}\n\nexport function sample(...args: any[]) {\n  let target\n  let name\n  let [[source, clock, fn], metadata] = processArgsToConfig(args)\n  let sid\n  let batch = true\n  let filter\n  const errorTitle = generateErrorTitle('sample', metadata)\n  /** config case */\n  if (\n    isVoid(clock) &&\n    isObject(source) &&\n    validateSampleConfig(source, errorTitle)\n  ) {\n    clock = source.clock\n    fn = source.fn\n    if ('batch' in source) {\n      batch = source.batch\n    } else {\n      deprecate(!('greedy' in source), 'greedy in sample', 'batch', errorTitle)\n      batch = !source.greedy\n    }\n    filter = source.filter\n    /** optional target & name accepted only from config */\n    target = source.target\n    name = source.name\n    sid = source.sid\n    source = source.source\n  }\n  return createSampling(\n    'sample',\n    clock,\n    source,\n    filter,\n    target,\n    fn,\n    name,\n    metadata,\n    batch,\n    true,\n    false,\n    sid,\n  )\n}\n\nexport const createSampling = (\n  method: string,\n  clock: DataCarrier | DataCarrier[] | void,\n  source: DataCarrier | Array<Store<any>> | Record<string, Store<any>> | void,\n  filter: any,\n  target: DataCarrier | DataCarrier[] | void,\n  fn: any,\n  name: string | undefined,\n  metadata: object | void,\n  batch: boolean,\n  targetMayBeStore: boolean,\n  filterRequired: boolean,\n  sid?: string | undefined,\n) => {\n  const errorTitle = generateErrorTitle(method, metadata)\n  const isUpward = !!target\n  assert(\n    !isVoid(source) || !isVoid(clock),\n    fieldErrorMessage(errorTitle, 'either source or clock'),\n  )\n  let sourceIsClock = false\n  if (isVoid(source)) {\n    sourceIsClock = true\n  } else if (!is.unit(source)) {\n    source = combine(source)\n  }\n  if (isVoid(clock)) {\n    /** still undefined! */\n    clock = source\n  } else {\n    assertNodeSet(clock, errorTitle, 'clock')\n    if (Array.isArray(clock)) {\n      clock = merge(clock as CommonUnit[])\n    }\n  }\n  if (sourceIsClock) {\n    source = clock\n  }\n  // @ts-expect-error\n  if (!metadata && !name) name = source.shortName\n  let filterType: 'none' | 'unit' | 'fn' = 'none'\n  if (filterRequired || filter) {\n    if (is.unit(filter)) {\n      filterType = 'unit'\n    } else {\n      assert(isFunction(filter), '`filter` should be function or unit')\n      filterType = 'fn'\n    }\n  }\n  if (target) {\n    assertNodeSet(target, errorTitle, 'target')\n    assertTarget(errorTitle, target)\n  } else {\n    if (\n      filterType === 'none' &&\n      targetMayBeStore &&\n      is.store(source) &&\n      is.store(clock)\n    ) {\n      const initialState = fn\n        ? fn(readRef(getStoreState(source)), readRef(getStoreState(clock)))\n        : readRef(getStoreState(source))\n      // @ts-expect-error\n      target = createStore(initialState, {name, sid, or: metadata})\n    } else {\n      target = createEvent({name, derived: true, or: metadata})\n      applyTemplate('sampleTarget', getGraph(target))\n    }\n  }\n  // const targetTemplate =\n  //   isUpward && is.unit(target) && getGraph(target).meta.nativeTemplate\n  const clockState = createStateRef()\n  let filterNodes: Cmd[] = []\n  if (filterType === 'unit') {\n    const [filterRef, hasFilter, isFilterStore] = syncSourceState(\n      filter as DataCarrier,\n      target,\n      // @ts-expect-error\n      clock,\n      clockState,\n      method,\n    )\n    if (!isFilterStore) {\n      filterNodes.push(...readAndFilter(hasFilter))\n    }\n    filterNodes.push(...readAndFilter(filterRef))\n  }\n  const jointNodeSeq: Cmd[] = []\n  if (sourceIsClock) {\n    if (batch) {\n      jointNodeSeq.push(read(clockState, true, true))\n    }\n  } else {\n    const [sourceRef, hasSource, isSourceStore] = syncSourceState(\n      // @ts-expect-error\n      source,\n      target,\n      clock,\n      clockState,\n      method,\n    )\n    if (!isSourceStore) {\n      jointNodeSeq.push(...readAndFilter(hasSource))\n    }\n    jointNodeSeq.push(read(sourceRef, true, batch))\n  }\n  const jointNode = createLinkNode(\n    // @ts-expect-error\n    clock,\n    target,\n    [\n      applyTemplate('sampleSourceLoader'),\n      mov({from: STACK, target: clockState}),\n      ...jointNodeSeq,\n      ...filterNodes,\n      read(clockState),\n      filterType === 'fn' && userFnCall((src, _, {a}) => filter(src, a), true),\n      fn && userFnCall(callStackAReg),\n      applyTemplate('sampleSourceUpward', isUpward),\n    ],\n    method,\n    fn,\n  )\n  // @ts-expect-error\n  own(source, [jointNode])\n  Object.assign(jointNode.meta, metadata, {joint: true})\n  return target\n}\n\nconst readAndFilter = (state: StateRef) => [\n  read(state),\n  calc((upd, scope, {a}) => a, true),\n]\n\nconst syncSourceState = (\n  source: DataCarrier,\n  target: DataCarrier | DataCarrier[],\n  clock: DataCarrier | DataCarrier[],\n  clockState: StateRef,\n  method: string,\n) => {\n  const isSourceStore = is.store(source)\n  const sourceRef = isSourceStore ? getStoreState(source) : createStateRef()\n  const hasSource = createStateRef(isSourceStore)\n  if (!isSourceStore) {\n    createNode({\n      parent: source,\n      node: [\n        mov({from: STACK, target: sourceRef}),\n        mov({from: VALUE, store: true, target: hasSource}),\n      ],\n      family: {owners: [source, target, clock], links: target},\n      meta: {op: method},\n      regional: true,\n    })\n  }\n  applyTemplate('sampleSource', hasSource, sourceRef, clockState)\n  return [sourceRef, hasSource, isSourceStore] as const\n}\n","import {assert} from '../throw'\nimport {forkPage, setForkPage} from '../kernel'\nimport type {Scope} from '../unit.h'\n\n/** bind event to scope */\nexport function scopeBind(\n  unit: (x: any) => any,\n  {scope, safe}: {scope?: Scope; safe?: true} = {},\n) {\n  assert(scope || forkPage || safe, 'scopeBind: scope not found')\n  const targetForkPage = scope || forkPage!\n\n  return (x: any) => {\n    let final: any\n    let failed = false\n\n    const lastForkPage = forkPage\n    function restoreLastForkPage() {\n      setForkPage(lastForkPage)\n    }\n\n    setForkPage(targetForkPage)\n    try {\n      final = unit(x)\n    } catch (err) {\n      final = err\n      failed = true\n    }\n    restoreLastForkPage()\n\n    if (failed) throw final\n\n    if (final instanceof Promise) {\n      final.then(restoreLastForkPage, restoreLastForkPage)\n    }\n\n    return final\n  }\n}\n","import {clearNode} from './clearNode'\nimport {createNode} from './createNode'\nimport type {Subscription, Unit, Compute, MovStoreToRegister} from './index.h'\nimport {step} from './step'\nimport {Scope} from './unit.h'\nimport {addUnsubscribe} from './subscription'\nimport {is} from './is'\n\nexport function createWatch<T>({\n  unit,\n  fn,\n  scope,\n  batch,\n}: {\n  unit: Unit<T> | Unit<T>[]\n  fn: (value: T) => any\n  scope?: Scope\n  batch?: boolean\n}): Subscription {\n  const seq: (Compute | MovStoreToRegister)[] = [\n    step.run({fn: value => fn(value)}),\n  ]\n  if (batch) {\n    seq.unshift(step.compute({priority: 'sampler', batch: true}))\n  }\n  if (is.store(unit)) {\n    seq.unshift(\n      step.mov({\n        store: (unit as any).stateRef,\n        to: 'stack',\n      }),\n    )\n  }\n  const units = Array.isArray(unit) ? unit : [unit]\n  if (scope) {\n    const unsubs: (() => void)[] = []\n    const scopeLinks = scope.additionalLinks\n\n    units.forEach(u => {\n      const links = scopeLinks[u.graphite.id] || []\n      scopeLinks[u.graphite.id] = links\n\n      const node = createNode({\n        node: prepareSeq(seq, u),\n        meta: {\n          watchOp: u.kind,\n        },\n      })\n\n      links.push(node)\n\n      unsubs.push(() => {\n        const idx = links.indexOf(node)\n        if (idx !== -1) links.splice(idx, 1)\n        clearNode(node)\n      })\n    })\n    return addUnsubscribe(() => {\n      unsubs.forEach(u => u())\n    })\n  } else {\n    const node = createNode({\n      node: seq,\n      parent: units,\n      family: {owners: units},\n    })\n    return addUnsubscribe(() => {\n      clearNode(node)\n    })\n  }\n}\n\nfunction prepareSeq(seq: (Compute | MovStoreToRegister)[], unit: any) {\n  if (is.store(unit)) {\n    return [\n      step.mov({\n        store: (unit as any).stateRef,\n        to: 'stack',\n      }),\n      ...seq,\n    ]\n  }\n\n  return seq\n}\n","export const observableSymbol =\n  (typeof Symbol !== 'undefined' && Symbol.observable) || '@@observable'\n","import type {Node, StateRef, NodeUnit} from './index.h'\nimport type {Scope, Store, CommonUnit, Domain} from './unit.h'\n\nexport const getGraph = (graph: NodeUnit): Node =>\n  (graph as {graphite: Node}).graphite || graph\nexport const getOwners = (node: Node) => node.family.owners\nexport const getLinks = (node: Node) => node.family.links\nexport const getStoreState = (store: Store<any>): StateRef => store.stateRef\nexport const getValue = (stack: any) => stack.value\nexport const getSubscribers = (store: Store<any>) => store.subscribers\nexport const getParent = (unit: any) => unit.parent\nexport const getForkPage = (val: any): Scope | void => val.scope\nexport const getMeta = (unit: NodeUnit, field: string) =>\n  getGraph(unit).meta[field]\nexport const setMeta = (unit: NodeUnit, field: string, value: unknown) =>\n  (getGraph(unit).meta[field] = value)\nexport const getCompositeName = (unit: CommonUnit | Domain) =>\n  unit.compositeName\n","import type {Kind, Unit} from './index.h'\nimport type {Domain, Effect, Event, Scope, Store} from './unit.h'\nimport {DOMAIN, STORE, EVENT, EFFECT, SCOPE} from './tag'\nimport {isObject, isFunction} from './is'\nimport {getMeta} from './getter'\nimport { UnitTargetable } from 'effector'\n\nexport const unit = (obj: unknown): obj is Unit<any> =>\n  (isFunction(obj) || isObject(obj)) && 'kind' in obj\n\nconst is = (type: Kind) => (obj: unknown) => unit(obj) && obj.kind === type\n\nexport const store = is(STORE) as (value: unknown) => value is Store<unknown>\nexport const event = is(EVENT) as (value: unknown) => value is Event<unknown>\nexport const effect = is(EFFECT) as (\n  value: unknown,\n) => value is Effect<unknown, unknown, unknown>\nexport const targetable = (obj: unknown): obj is UnitTargetable<unknown> => unit(obj) && !!(obj as any).targetable\nexport const domain = is(DOMAIN) as (value: unknown) => value is Domain\nexport const scope = is(SCOPE) as (value: unknown) => value is Scope\nexport const attached = (unit: unknown) =>\n  effect(unit) && getMeta(unit, 'attached') === true\n","const idCount = () => {\n  let id = 0\n  return () => `${++id}`\n}\n\nexport const nextUnitID = idCount()\nexport const nextStepID = idCount()\nexport const nextNodeID = idCount()\nexport const nextEffectID = idCount()\n","import type {Template} from '../forest/index.h'\nimport type {NodeUnit, Node, ID} from './index.h'\nimport {getParent, getGraph} from './getter'\nimport {createNode} from './createNode'\n\ntype DeclarationSourceReporter = (\n  node: Node | 'region',\n  regionStack: RegionStack | null,\n) => void\n\nlet reporter: DeclarationSourceReporter\n\nexport const setGraphInspector = (fn: DeclarationSourceReporter) => {\n  reporter = fn\n}\n\ntype RegionStack = {\n  id: ID\n  parent: RegionStack | null\n  value: any\n  template: Template | null\n  sidRoot?: string\n  meta:\n    | Record<string, unknown>\n    | {\n        type: 'factory'\n        sid?: string\n        name?: string\n        loc: unknown\n        method?: string\n      }\n}\n\nexport let regionStack: RegionStack | null = null\n\nexport const reportDeclaration = (node: Node | 'region') => {\n  if (reporter) {\n    reporter(node, regionStack)\n  }\n}\n\nexport const readTemplate = (): Template | null =>\n  regionStack && regionStack.template\nexport const readSidRoot = (sid?: string | null) => {\n  if (sid && regionStack && regionStack.sidRoot)\n    sid = `${regionStack.sidRoot}|${sid}`\n  return sid\n}\n\nexport function withRegion<T = void>(unit: NodeUnit, cb: () => T): T {\n  const meta = getGraph(unit).meta || {}\n\n  regionStack = {\n    id: getGraph(unit).id,\n    parent: regionStack,\n    value: unit,\n    template: meta.template || readTemplate(),\n    sidRoot: meta.sidRoot || (regionStack && regionStack.sidRoot),\n    meta: meta,\n  }\n  try {\n    return cb()\n  } finally {\n    reportDeclaration('region')\n    regionStack = getParent(regionStack)\n  }\n}\n\nexport const withFactory = ({\n  sid,\n  name,\n  loc,\n  method,\n  fn,\n}: {\n  sid: string\n  name?: string\n  loc?: any\n  method?: string\n  fn: () => any\n}) => {\n  const factoryRootNode = createNode({\n    meta: {sidRoot: readSidRoot(sid), sid, name, loc, method, type: 'factory'},\n  })\n\n  return withRegion(factoryRootNode, fn)\n}\n","import type {NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks} from './getter'\nimport {DOMAIN, CROSSLINK} from './tag'\nimport {add, forEach} from './collection'\n\nexport const own = (ownerUnit: NodeUnit, links: NodeUnit[]) => {\n  const owner = getGraph(ownerUnit)\n  forEach(links, _link => {\n    const link = getGraph(_link)\n    if (owner.family.type !== DOMAIN) link.family.type = CROSSLINK\n    add(getOwners(link), owner)\n    add(getLinks(owner), link)\n  })\n}\n","export * as is from './validate'\nimport {forEach} from './collection'\nimport {assert, deprecate} from './throw'\nimport {arrifyNodes} from './createNode'\nimport type {NodeUnit} from './index.h'\nimport type {DataCarrier} from './unit.h'\nimport {getMeta} from './getter'\n\nexport const isObject = (value: unknown): value is Record<any, any> =>\n  typeof value === 'object' && value !== null\nexport const isFunction = (value: unknown): value is Function =>\n  typeof value === 'function'\n\nexport const isVoid = (value: unknown): value is void => value === undefined\n\nexport const assertObject = (value: unknown) =>\n  assert(\n    isObject(value) || isFunction(value),\n    'expect first argument be an object',\n  ) // or function\n\nconst assertNodeSetItem = (\n  value: unknown,\n  method: string,\n  valueName: string,\n  reason: string,\n): asserts value is DataCarrier =>\n  assert(\n    !(\n      (!isObject(value) && !isFunction(value)) ||\n      (!('family' in value) && !('graphite' in value))\n    ),\n    `${method}: expect ${valueName} to be a unit (store, event or effect)${reason}`,\n  )\n\nexport const assertNodeSet = (\n  value: unknown,\n  method: string,\n  valueName: string,\n) => {\n  if (Array.isArray(value)) {\n    forEach(value, (item, i) =>\n      assertNodeSetItem(item, method, `${i} item of ${valueName}`, ''),\n    )\n  } else {\n    //@ts-expect-error some ts assertion edge case\n    assertNodeSetItem(value, method, valueName, ' or array of units')\n  }\n}\n\nexport const assertTarget = (\n  method: string,\n  target: NodeUnit | NodeUnit[],\n  targetField: string = 'target',\n) =>\n  forEach(arrifyNodes(target), item =>\n    assert(\n      !getMeta(item, 'derived'),\n      `${method}: derived unit in \"${targetField}\" is not supported, use createStore/createEvent instead\"`,\n    ),\n  )\n","import type {Stack} from './index.h'\n\nexport const callStackAReg = (\n  stack: any,\n  {fn}: {[key: string]: any},\n  {a}: Stack,\n) => fn(stack, a)\nexport const callARegStack = (\n  stack: any,\n  {fn}: {[key: string]: any},\n  {a}: Stack,\n) => fn(a, stack)\nexport const callStack = (stack: any, {fn}: {[key: string]: any}, _: Stack) =>\n  fn(stack)\n","import type {\n  StateRef,\n  Compute,\n  MovValueToRegister,\n  MovValueToStore,\n  MovStoreToRegister,\n  MovStoreToStore,\n  MovRegisterToStore,\n  Stack,\n} from './index.h'\nimport {nextStepID} from './id'\nimport {EFFECT, REG_A, SAMPLER, STACK, STORE} from './tag'\nimport type {BarrierPriorityTag} from './kernel'\nimport {callStack} from './caller'\n\nconst cmd = <Type extends 'compute' | 'mov'>(\n  type: Type,\n  data: any,\n  priority?: BarrierPriorityTag | false,\n  batch?: boolean,\n) => {\n  const result: {\n    id: string\n    type: Type\n    data: any\n    order?: {\n      priority: BarrierPriorityTag\n      barrierID?: number\n    }\n  } = {\n    id: nextStepID(),\n    type,\n    data,\n  }\n  if (priority) {\n    result.order = {priority}\n    if (batch) result.order.barrierID = ++nextBarrierID\n  }\n  return result\n}\n\nlet nextBarrierID = 0\n\nexport const mov: {\n  <T>(data: {\n    from: 'value'\n    store: T\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovValueToStore<T>\n  <T>(data: {\n    from: 'value'\n    to: 'stack' | 'a' | 'b'\n    store: T\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovValueToRegister<T>\n  (data: {\n    from: 'a' | 'b' | 'stack'\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovRegisterToStore\n  (data: {\n    from: 'a' | 'b' | 'stack'\n    to: 'a' | 'b' | 'stack'\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovRegisterToStore\n  (data: {\n    store: StateRef\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovStoreToStore\n  (data: {\n    store: StateRef\n    to: 'stack' | 'a' | 'b'\n    batch?: boolean\n    priority?: BarrierPriorityTag | false\n  }): MovStoreToRegister\n  (data: {\n    store: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag | false\n  }): MovStoreToRegister\n  // (data: {\n  //   from?: 'value' | 'store' | 'stack' | 'a' | 'b'\n  //   to?: 'stack' | 'a' | 'b' | 'store'\n  //   store?: StateRef\n  //   target?: StateRef\n  // }): Mov\n} = ({\n  from = STORE,\n  store,\n  target,\n  to = target ? STORE : STACK,\n  batch,\n  priority,\n}: {\n  from?: 'value' | 'store' | 'stack' | 'a' | 'b'\n  to?: 'stack' | 'a' | 'b' | 'store'\n  store?: StateRef\n  target?: StateRef\n  batch?: boolean\n  priority?: BarrierPriorityTag | false\n}) => cmd('mov', {from, store, to, target}, priority, batch)\n\nexport const compute = <\n  LocalValues extends {[key: string]: any} = {[key: string]: any},\n>({\n  fn,\n  batch,\n  priority,\n  safe = false,\n  filter = false,\n  pure = false,\n}: {\n  fn?: (data: any, scope: LocalValues, stack: Stack) => any\n  batch?: boolean\n  priority?: BarrierPriorityTag | false\n  safe?: boolean\n  filter?: boolean\n  pure?: boolean\n}): Compute => cmd('compute', {fn, safe, filter, pure}, priority, batch)\n\nexport const filter = ({\n  fn,\n  pure,\n}: {\n  fn(data: any, scope: {[key: string]: any}, stack: Stack): any\n  pure?: boolean\n}) => compute({fn, filter: true, pure})\n\nexport const run = ({\n  fn,\n}: {\n  fn(data: any, scope: {[key: string]: any}, stack: Stack): any\n}) => compute({fn, priority: EFFECT})\n\nexport const calc = <\n  LocalValues extends {[key: string]: any} = {[key: string]: any},\n>(\n  fn: (data: any, scope: LocalValues, stack: Stack) => any,\n  filter?: boolean,\n  isEffect?: boolean,\n) => compute({fn, safe: true, filter, priority: isEffect && EFFECT})\n\n/**\n * `read(ref, true, true)`: **reg.stack** with **sampler** batch\n *\n * `read(ref, true, false)`: **reg.stack** without batch\n *\n * `read(ref, false, true)`: **reg.a** with **sampler** batch\n *\n * `read(ref, false, false)`: **reg.a** without batch\n *\n */\nexport const read = (\n  store: StateRef,\n  toStack?: boolean,\n  samplerPriority?: boolean,\n) =>\n  mov({\n    store,\n    to: toStack ? STACK : REG_A,\n    priority: samplerPriority && SAMPLER,\n    batch: true,\n  })\n\nexport const userFnCall = (\n  fn: (data: any, scope: {[key: string]: any}, stack: Stack) => any = callStack,\n  isFilter?: boolean,\n) => compute({fn, pure: true, filter: isFilter})\n\nexport const step = {mov, compute, filter, run}\n","import type {StateRef, StateRefOp} from './index.h'\nimport {nextStepID} from './id'\nimport {add} from './collection'\n\nexport const createStateRef = (current?: any): StateRef => ({\n  id: nextStepID(),\n  current,\n  initial: current,\n})\nexport const readRef = ({current}: StateRef | {current: any}) => current\n\nexport const addRefOp = (ref: StateRef, op: StateRefOp) => {\n  if (!ref.before) ref.before = []\n  add(ref.before!, op as any)\n}\n","import {Node, NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks, getSubscribers} from './getter'\nimport {is} from './is'\nimport {removeItem} from './collection'\nimport {CROSSLINK} from './tag'\n\nconst removeFromNode = (currentNode: Node, targetNode: Node) => {\n  removeItem(currentNode.next, targetNode)\n  removeItem(getOwners(currentNode), targetNode)\n  removeItem(getLinks(currentNode), targetNode)\n}\nconst clearNodeNormalized = (\n  targetNode: Node,\n  deep: boolean,\n  isDomainUnit: boolean,\n) => {\n  targetNode.next.length = 0\n  targetNode.seq.length = 0\n  //@ts-expect-error\n  targetNode.scope = null\n  let currentNode\n  let list = getLinks(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (\n      deep ||\n      (isDomainUnit && targetNode.meta.op !== 'sample') ||\n      currentNode.family.type === CROSSLINK\n    ) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        currentNode.meta.op !== 'on' && isDomainUnit,\n      )\n    }\n  }\n  list = getOwners(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (isDomainUnit && currentNode.family.type === CROSSLINK) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        currentNode.meta.op !== 'on' && isDomainUnit,\n      )\n    }\n  }\n}\nconst clearMap = (map: Map<any, any> | Set<any>) => map.clear()\nexport const clearNode = (\n  graphite: NodeUnit,\n  {\n    deep,\n  }: {\n    deep?: boolean\n  } = {},\n) => {\n  let isDomainUnit = false\n  //@ts-expect-error\n  if (graphite.ownerSet) graphite.ownerSet.delete(graphite)\n  if (is.store(graphite)) {\n    clearMap(getSubscribers(graphite))\n  } else if (is.domain(graphite)) {\n    isDomainUnit = true\n    const history = graphite.history\n    clearMap(history.events)\n    clearMap(history.effects)\n    clearMap(history.stores)\n    clearMap(history.domains)\n  }\n  clearNodeNormalized(getGraph(graphite), !!deep, isDomainUnit)\n}\n","import {processArgsToConfig} from './config'\nimport {createNode} from './createNode'\nimport type {Subscription, NodeUnit, Cmd} from './index.h'\nimport {createSubscription} from './subscription'\nimport {assertNodeSet, assertTarget} from './is'\nimport {deprecate} from './throw'\nimport {generateErrorTitle} from './naming'\n\nexport const createLinkNode = (\n  parent: NodeUnit | NodeUnit[],\n  child: NodeUnit | NodeUnit[],\n  node?: Array<Cmd | false | void | null>,\n  op?: string,\n  scopeFn?: Function,\n) =>\n  createNode({\n    node,\n    parent,\n    child,\n    scope: {fn: scopeFn},\n    meta: {op},\n    family: {owners: [parent, child], links: child},\n    regional: true,\n  })\nexport const forward = (opts: {\n  from: NodeUnit | NodeUnit[]\n  to: NodeUnit | NodeUnit[]\n  meta?: Record<string, any>\n}): Subscription => {\n  const METHOD = 'forward'\n  const [{from, to}, config] = processArgsToConfig(opts, true)\n  const errorTitle = generateErrorTitle(METHOD, config)\n  deprecate(false, METHOD, 'sample', errorTitle)\n  assertNodeSet(from, errorTitle, '\"from\"')\n  assertNodeSet(to, errorTitle, '\"to\"')\n  assertTarget(errorTitle, to, 'to')\n  return createSubscription(\n    createNode({\n      parent: from,\n      child: to,\n      meta: {op: METHOD, config},\n      family: {},\n      regional: true,\n    }),\n  )\n}\n","import {run} from './step'\nimport {callStack} from './caller'\nimport {createNode} from './createNode'\nimport {Subscription, NodeUnit} from './index.h'\nimport {createSubscription} from './subscription'\nimport {assert} from './throw'\nimport {isFunction} from './is'\n\nexport const watchUnit = (\n  unit: NodeUnit,\n  handler: (payload: any) => any,\n): Subscription => {\n  assert(isFunction(handler), '.watch argument should be a function')\n  return createSubscription(\n    createNode({\n      scope: {fn: handler},\n      node: [run({fn: callStack})],\n      parent: unit,\n      meta: {op: 'watch'},\n      family: {owners: unit},\n      regional: true,\n    }),\n  )\n}\n"],"names":["e","require","k","Object","is","a","b","l","useState","m","useEffect","n","useLayoutEffect","p","useDebugValue","r","getSnapshot","value","d","f","u","window","document","createElement","inst","c","g","exports","useSyncExternalStore","h","q","t","useRef","v","useMemo","w","useSyncExternalStoreWithSelector","current","hasValue","module","S","unit","E","o","Array","isArray","s","stale","justSubscribed","scope","i","hasOwnProperty","call","concat","event","effect","push","keys","values","storeKeys","eventKeys","eventValues","fn","batch","y","length","U","includes","indexOf","O","V","forceScope","Error","A","R","stateReader","getState","Provider","L","forEach","node","from","source","parent","to","target","child","meta","family","type","regional","arguments","undefined","Se","links","owners","ie","id","fe","seq","next","T","ge","we","B","at","et","params","defer","page","stack","Qe","tt","isRoot","currentPage","isWatch","rt","isPure","nt","Ke","idx","reg","fail","order","priority","barrierID","fullID","Ze","has","add","Xe","delete","data","store","ct","pt","softRead","Be","lt","op","pure","safe","mt","filter","dt","needFxCounter","fxCount","storeChange","warnSerialize","warnSerializeNode","additionalLinks","Q","K","fullName","toString","path","shortName","name","named","loc","file","line","column","ze","or","and","$e","subscription","unsubscribe","be","handlers","_len","_key","ht","_len2","_key2","G","template","H","st","create","assign","graphite","xt","actualOp","watch","$t","map","zt","Ve","Oe","filterMap","_e","xe","prepend","targetable","wt","Mt","domain","hooks","J","ye","je","Me","ce","off","W","set","kt","jt","Ie","Le","derived","skipVoid","subscribers","Map","updates","defaultState","stateRef","setState","reset","_len3","_key3","on","get","We","noInit","defaultConfig","updateFilter","state","Ee","_ref","console","error","At","Ne","qe","$","M","sid","x","reinit","_len4","_key4","Y","slice","Ct","req","Promise","rs","rj","catch","handler","kind","use","getCurrent","finally","done","_ref2","status","result","_ref3","doneData","_ref4","failData","_ref5","compositeName","unitMap","sidMap","runnerFn","args","It","Nt","then","fx","runner","_ref6","fxID","pe","ot","inFlight","serialize","pending","Rt","Ft","_len6","_key6","clock","greedy","qt","F","D","_ref10","Te","run","unshift","compute","mov","P","watchOp","splice","vt","_","Symbol","observable","getMeta","setMeta","X","Z","ee","te","re","ne","ae","__proto__","attached","se","removeItem","deprecate","le","idCount","de","ue","me","readTemplate","ve","sidRoot","own","flat","Ae","assertNodeSetItem","assertNodeSet","Ce","callStackAReg","_ref12","_ref13","callARegStack","_ref14","_ref15","callStack","_ref16","Re","cmd","Fe","_ref17","De","_ref18","Pe","_ref19","calc","read","_ref20","initial","_ref21","addRefOp","before","He","Ue","merge","Ye","Ge","Je","first","last","size","deleteMin","pushFirstHeapItem","pushHeap","Set","getPageForRef","getPageRef","ft","initRefInScope","idMap","sidIdMap","fromSerialize","field","tryRun","failReason","gt","removeFromNode","yt","clearNodeNormalized","pop","bt","clear","deep","ownerSet","history","events","effects","stores","domains","createLinkNode","watchUnit","initUnit","unitId","config","getType","subscribe","nativeTemplate","deriveEvent","updateStore","storeCombination","_ref22","key","defaultShape","runFn","onSettled","Ot","_ref23","fieldErrorMessage","createSampling","Pt","Dt","z","_ref24","joint","_ref25","syncSourceState"],"sourceRoot":""}